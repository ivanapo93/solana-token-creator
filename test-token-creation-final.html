<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Token Creator Test Suite</title>
    
    <!-- Buffer Polyfill -->
    <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
    <script>
        console.log('ðŸ”§ Initializing Buffer polyfill...');
        window.Buffer = buffer.Buffer;
    </script>
    
    <!-- Solana dependencies with specific versions -->
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.73.0/lib/index.iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.7/lib/index.iife.min.js"></script>
    
    <!-- Our token creator support modules -->
    <script src="server-fallback-config.js"></script>
    <script src="token-creation-logger.js"></script>
    
    <style>
        :root {
            --primary: #512DA8;
            --secondary: #7B1FA2;
            --accent: #00BCD4;
            --success: #4CAF50;
            --warning: #FFC107;
            --error: #F44336;
            --gray-bg: #F5F5F5;
            --white: #FFFFFF;
            --dark-text: #212121;
            --light-text: #757575;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--gray-bg);
            color: var(--dark-text);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--white);
            padding: 30px 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .card {
            background-color: var(--white);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .card h2 {
            color: var(--primary);
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 10px;
        }
        
        .test-section {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 4px;
            background-color: var(--gray-bg);
        }
        
        .test-description {
            font-weight: 500;
            margin-bottom: 10px;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background-color: var(--secondary);
        }
        
        button:disabled {
            background-color: var(--light-text);
            cursor: not-allowed;
        }
        
        .success-btn {
            background-color: var(--success);
        }
        
        .success-btn:hover {
            background-color: #388E3C;
        }
        
        .warning-btn {
            background-color: var(--warning);
            color: var(--dark-text);
        }
        
        .warning-btn:hover {
            background-color: #FFA000;
        }
        
        .danger-btn {
            background-color: var(--error);
        }
        
        .danger-btn:hover {
            background-color: #D32F2F;
        }
        
        .test-result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        
        .success {
            background-color: rgba(76, 175, 80, 0.1);
            border-left: 4px solid var(--success);
            color: #388E3C;
        }
        
        .warning {
            background-color: rgba(255, 193, 7, 0.1);
            border-left: 4px solid var(--warning);
            color: #F57F17;
        }
        
        .error {
            background-color: rgba(244, 67, 54, 0.1);
            border-left: 4px solid var(--error);
            color: #D32F2F;
        }
        
        .info {
            background-color: rgba(0, 188, 212, 0.1);
            border-left: 4px solid var(--accent);
            color: #0097A7;
        }
        
        .logs {
            height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            background-color: #212121;
            color: #EEFFFF;
            padding: 15px;
            border-radius: 4px;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .progress-bar {
            height: 10px;
            width: 100%;
            background-color: #E0E0E0;
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .timestamp {
            color: #78909C;
            margin-right: 8px;
        }
        
        .log-info { color: #42A5F5; }
        .log-success { color: #66BB6A; }
        .log-warning { color: #FFCA28; }
        .log-error { color: #EF5350; }
        
        .connectivity-status {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .status-online { background-color: var(--success); }
        .status-offline { background-color: var(--error); }
        .status-warning { background-color: var(--warning); }
        
        .code-block {
            background-color: #F5F5F5;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Solana Token Creator Test Suite</h1>
            <p class="subtitle">Comprehensive testing for token creation functionality</p>
        </header>
        
        <div class="card">
            <h2>System Status</h2>
            
            <div class="status-bar">
                <div id="test-status">Status: Ready to run tests</div>
                <div id="test-counter">0/0 Tests Completed</div>
            </div>
            
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progress-bar"></div>
            </div>
            
            <div class="test-section">
                <div class="test-description">1. Dependency Check</div>
                <button onclick="runDependencyCheck()">Check Dependencies</button>
                <div id="dependency-result" class="test-result"></div>
            </div>
            
            <div class="connectivity-status">
                <span class="status-indicator" id="wallet-indicator"></span>
                <span id="wallet-status">Wallet: Disconnected</span>
            </div>
            
            <div class="connectivity-status">
                <span class="status-indicator" id="rpc-indicator"></span>
                <span id="rpc-status">RPC: Not connected</span>
            </div>
            
            <button id="connect-wallet-btn" onclick="connectWallet()">Connect Phantom Wallet</button>
        </div>
        
        <div class="card">
            <h2>Functionality Tests</h2>
            
            <div class="test-grid">
                <div class="test-section">
                    <div class="test-description">2. Buffer Polyfill Test</div>
                    <button onclick="testBufferPolyfill()">Test Buffer</button>
                    <div id="buffer-result" class="test-result"></div>
                </div>
                
                <div class="test-section">
                    <div class="test-description">3. RPC Fallback Test</div>
                    <button onclick="testRPCFallback()">Test RPC Fallback</button>
                    <div id="rpc-result" class="test-result"></div>
                </div>
                
                <div class="test-section">
                    <div class="test-description">4. Error Handling Test</div>
                    <button onclick="testErrorHandling()">Test Error Handling</button>
                    <div id="error-result" class="test-result"></div>
                </div>
                
                <div class="test-section">
                    <div class="test-description">5. Transaction Logger Test</div>
                    <button onclick="testTransactionLogger()">Test Logger</button>
                    <div id="logger-result" class="test-result"></div>
                </div>
                
                <div class="test-section">
                    <div class="test-description">6. Create Test Token</div>
                    <button id="create-token-btn" onclick="testCreateToken()" disabled>Create Test Token</button>
                    <div id="token-result" class="test-result"></div>
                </div>
                
                <div class="test-section">
                    <div class="test-description">7. Authority Revocation Test</div>
                    <button id="revoke-authority-btn" onclick="testRevokeAuthority()" disabled>Test Revocation</button>
                    <div id="revoke-result" class="test-result"></div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Log Output</h2>
            <div id="logs" class="logs"></div>
            <button onclick="clearLogs()" class="warning-btn">Clear Logs</button>
            <button onclick="runAllTests()" class="success-btn" id="run-all-btn">Run All Tests</button>
        </div>
    </div>
    
    <script>
        // Global variables
        let logger = new TokenCreationLogger({
            logElementId: 'logs',
            developmentMode: true,
            captureTransactions: true
        });
        let wallet = null;
        let connection = null;
        let publicKey = null;
        let rpcManager = new RpcConnectionManager();
        let testTokenMint = null;
        
        // Completed test counter
        let completedTests = 0;
        let totalTests = 7;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateProgressBar();
            logger.info('Test suite initialized');
        });
        
        function updateProgressBar() {
            document.getElementById('progress-bar').style.width = `${(completedTests / totalTests) * 100}%`;
            document.getElementById('test-counter').textContent = `${completedTests}/${totalTests} Tests Completed`;
        }
        
        function updateTestStatus(message, isError = false) {
            document.getElementById('test-status').textContent = `Status: ${message}`;
            document.getElementById('test-status').style.color = isError ? '#F44336' : '';
        }
        
        function displayResult(elementId, message, status) {
            const element = document.getElementById(elementId);
            element.className = `test-result ${status}`;
            element.textContent = message;
        }
        
        function clearLogs() {
            logger.clearLogs();
        }
        
        // Run all tests sequentially
        async function runAllTests() {
            updateTestStatus('Running all tests...');
            document.getElementById('run-all-btn').disabled = true;
            
            // Reset counters
            completedTests = 0;
            updateProgressBar();
            
            try {
                // Test 1: Dependencies
                await runDependencyCheck();
                
                // Test 2: Buffer
                await testBufferPolyfill();
                
                // Test 3: RPC Fallback
                await testRPCFallback();
                
                // Test 4: Error Handling
                await testErrorHandling();
                
                // Test 5: Transaction Logger
                await testTransactionLogger();
                
                // Connect wallet if not connected (needed for token tests)
                if (!wallet) {
                    try {
                        await connectWallet();
                    } catch (error) {
                        logger.error('Could not connect wallet for token tests', error);
                        updateTestStatus('Cannot continue - wallet connection required', true);
                        document.getElementById('run-all-btn').disabled = false;
                        return;
                    }
                }
                
                // Test 6: Token Creation
                await testCreateToken();
                
                // Test 7: Authority Revocation
                if (testTokenMint) {
                    await testRevokeAuthority();
                }
                
                updateTestStatus('All tests completed!');
            } catch (error) {
                logger.error('Test suite error', error);
                updateTestStatus('Test suite encountered errors', true);
            } finally {
                document.getElementById('run-all-btn').disabled = false;
            }
        }
        
        // Test 1: Check dependencies
        async function runDependencyCheck() {
            logger.info('Running dependency check...');
            
            const dependencies = [
                { name: 'Buffer', object: window.Buffer },
                { name: 'Solana Web3.js', object: window.solanaWeb3 },
                { name: 'SPL Token', object: window.splToken },
                { name: 'RPC Manager', object: window.RpcConnectionManager },
                { name: 'Logger', object: window.TokenCreationLogger }
            ];
            
            let allLoaded = true;
            let loadedCount = 0;
            let message = 'Dependencies: ';
            
            for (const dep of dependencies) {
                if (dep.object) {
                    loadedCount++;
                    message += `${dep.name} âœ“ `;
                    logger.info(`${dep.name} loaded successfully`);
                } else {
                    allLoaded = false;
                    message += `${dep.name} âœ— `;
                    logger.error(`${dep.name} not loaded`);
                }
            }
            
            const status = allLoaded ? 'success' : 'error';
            displayResult('dependency-result', `${message} (${loadedCount}/${dependencies.length})`, status);
            
            completedTests++;
            updateProgressBar();
            
            return allLoaded;
        }
        
        // Test 2: Buffer polyfill
        async function testBufferPolyfill() {
            logger.info('Testing Buffer polyfill...');
            
            try {
                // Test basic Buffer functionality
                const testBuffer = Buffer.alloc(32);
                const testFromString = Buffer.from('TestString', 'utf8');
                
                // Test with Uint8Array conversion (critical for crypto operations)
                const testUint8Array = new Uint8Array(32).fill(1);
                const bufFromUint8 = Buffer.from(testUint8Array);
                
                // Test string conversion
                const testString = 'Hello Solana';
                const buf = Buffer.from(testString, 'utf8');
                const roundTrip = buf.toString('utf8');
                const matchesOriginal = testString === roundTrip;
                
                if (testBuffer instanceof Buffer && 
                    testFromString instanceof Buffer && 
                    bufFromUint8 instanceof Buffer && 
                    matchesOriginal) {
                    
                    logger.success('Buffer polyfill tests passed');
                    displayResult('buffer-result', 'All Buffer tests passed successfully', 'success');
                } else {
                    throw new Error('Buffer tests failed');
                }
            } catch (error) {
                logger.error('Buffer polyfill test failed', error);
                displayResult('buffer-result', `Buffer test failed: ${error.message}`, 'error');
            }
            
            completedTests++;
            updateProgressBar();
        }
        
        // Test 3: RPC Fallback system
        async function testRPCFallback() {
            logger.info('Testing RPC fallback mechanism...');
            
            try {
                // Test RPC manager instantiation
                const testManager = new RpcConnectionManager();
                
                // Check if endpoints are available
                const endpoints = testManager.getAllEndpoints();
                if (!endpoints || endpoints.length === 0) {
                    throw new Error('No RPC endpoints configured');
                }
                
                // Test endpoint switching
                const initialEndpoint = testManager.getCurrentEndpoint();
                const secondEndpoint = testManager.switchToNextEndpoint();
                
                if (!secondEndpoint || initialEndpoint.url === secondEndpoint.url && endpoints.length > 1) {
                    throw new Error('Endpoint switching failed');
                }
                
                // Reset to initial endpoint
                while (testManager.getCurrentEndpoint().url !== initialEndpoint.url) {
                    testManager.switchToNextEndpoint();
                }
                
                // Test connection with fallback (don't await, just test the function exists)
                if (typeof testManager.createConnectionWithFallback !== 'function') {
                    throw new Error('Fallback connection method not implemented');
                }
                
                logger.success('RPC fallback tests passed');
                displayResult('rpc-result', 
                    `RPC system functional with ${endpoints.length} endpoints available`, 'success');
            } catch (error) {
                logger.error('RPC fallback test failed', error);
                displayResult('rpc-result', `RPC test failed: ${error.message}`, 'error');
            }
            
            completedTests++;
            updateProgressBar();
        }
        
        // Test 4: Error handling system
        function testErrorHandling() {
            logger.info('Testing error handling system...');
            
            try {
                // Test basic error logging
                logger.error('Test error message');
                
                // Test user-friendly error conversion
                const testErrors = [
                    { technical: 'Transaction simulation failed: Blockhash not found', expected: true },
                    { technical: 'insufficient funds for rent', expected: true },
                    { technical: 'User rejected the request', expected: true },
                    { technical: 'Some random error message', expected: false }
                ];
                
                let allPassed = true;
                let convertedCount = 0;
                
                for (const testError of testErrors) {
                    const friendly = logger.getUserFriendlyError(testError.technical);
                    const isDifferent = friendly !== `Error: ${testError.technical}. Please try again or check the logs for more details.`;
                    
                    // If we expect conversion and it didn't happen, or vice versa
                    if (testError.expected !== isDifferent) {
                        allPassed = false;
                        logger.warning(`Error conversion test failed for: ${testError.technical}`);
                    } else if (isDifferent) {
                        convertedCount++;
                    }
                }
                
                if (allPassed) {
                    logger.success('Error handling tests passed');
                    displayResult('error-result', 
                        `Error handling system working (${convertedCount}/${testErrors.length} conversions)`, 'success');
                } else {
                    throw new Error('Some error conversions failed');
                }
            } catch (error) {
                logger.error('Error handling test failed', error);
                displayResult('error-result', `Error handling test failed: ${error.message}`, 'error');
            }
            
            completedTests++;
            updateProgressBar();
        }
        
        // Test 5: Transaction logger
        function testTransactionLogger() {
            logger.info('Testing transaction logger...');
            
            try {
                // Test transaction tracking
                const transactionId = 'test-tx-' + Date.now();
                
                // Start transaction
                const tx = logger.startTransaction(transactionId, 'Test Transaction', { test: true });
                if (!tx) throw new Error('Failed to create transaction');
                
                // Add steps
                logger.addTransactionStep(transactionId, 'Step 1', 'completed');
                logger.addTransactionStep(transactionId, 'Step 2', 'completed');
                
                // Complete transaction
                const completedTx = logger.completeTransaction(transactionId, 'success');
                if (!completedTx) throw new Error('Failed to complete transaction');
                
                // Check if transaction was properly tracked
                const transactions = logger.getTransactions();
                const foundTx = transactions.find(t => t.id === transactionId);
                
                if (!foundTx) throw new Error('Transaction not found in log');
                if (foundTx.steps.length !== 2) throw new Error('Transaction steps not recorded correctly');
                
                logger.success('Transaction logger tests passed');
                displayResult('logger-result', 'Transaction logging system functional', 'success');
            } catch (error) {
                logger.error('Transaction logger test failed', error);
                displayResult('logger-result', `Logger test failed: ${error.message}`, 'error');
            }
            
            completedTests++;
            updateProgressBar();
        }
        
        // Connect to Phantom wallet
        async function connectWallet() {
            try {
                logger.info('Attempting to connect wallet...');
                
                // Check if Phantom is installed
                if (!window.solana || !window.solana.isPhantom) {
                    logger.error('Phantom wallet not detected');
                    document.getElementById('wallet-status').textContent = 'Wallet: Phantom not installed';
                    document.getElementById('wallet-indicator').className = 'status-indicator status-error';
                    return;
                }
                
                // Connect to wallet
                const resp = await window.solana.connect();
                wallet = window.solana;
                publicKey = resp.publicKey;
                
                // Update UI
                document.getElementById('wallet-status').textContent = `Wallet: Connected (${publicKey.toString().substring(0, 8)}...)`;
                document.getElementById('wallet-indicator').className = 'status-indicator status-online';
                document.getElementById('connect-wallet-btn').textContent = 'Disconnect Wallet';
                document.getElementById('connect-wallet-btn').onclick = disconnectWallet;
                
                logger.success(`Wallet connected: ${publicKey.toString()}`);
                
                // Try to connect to RPC
                await connectToRPC();
                
                // Enable token creation tests
                document.getElementById('create-token-btn').disabled = false;
                
                return true;
            } catch (error) {
                logger.error('Failed to connect wallet', error);
                document.getElementById('wallet-indicator').className = 'status-indicator status-offline';
                return false;
            }
        }
        
        // Disconnect wallet
        function disconnectWallet() {
            try {
                if (wallet) {
                    wallet.disconnect();
                    wallet = null;
                    publicKey = null;
                    connection = null;
                }
                
                // Update UI
                document.getElementById('wallet-status').textContent = 'Wallet: Disconnected';
                document.getElementById('wallet-indicator').className = 'status-indicator status-offline';
                document.getElementById('connect-wallet-btn').textContent = 'Connect Phantom Wallet';
                document.getElementById('connect-wallet-btn').onclick = connectWallet;
                
                // Disable token tests
                document.getElementById('create-token-btn').disabled = true;
                document.getElementById('revoke-authority-btn').disabled = true;
                
                // Update RPC status
                document.getElementById('rpc-status').textContent = 'RPC: Not connected';
                document.getElementById('rpc-indicator').className = 'status-indicator status-offline';
                
                logger.info('Wallet disconnected');
            } catch (error) {
                logger.error('Error disconnecting wallet', error);
            }
        }
        
        // Connect to RPC with fallback
        async function connectToRPC() {
            try {
                logger.info('Connecting to Solana RPC...');
                document.getElementById('rpc-status').textContent = 'RPC: Connecting...';
                document.getElementById('rpc-indicator').className = 'status-indicator status-warning';
                
                // Use RPC manager to create connection with fallback
                connection = await rpcManager.createConnectionWithFallback(
                    solanaWeb3,
                    (msg, level) => logger[level ? level : 'info'](msg)
                );
                
                if (connection) {
                    const endpoint = rpcManager.getCurrentEndpoint();
                    document.getElementById('rpc-status').textContent = `RPC: Connected (${endpoint.name})`;
                    document.getElementById('rpc-indicator').className = 'status-indicator status-online';
                    logger.success(`Connected to RPC: ${endpoint.name}`);
                    return true;
                } else {
                    throw new Error('Could not connect to any RPC endpoint');
                }
            } catch (error) {
                document.getElementById('rpc-status').textContent = 'RPC: Connection failed';
                document.getElementById('rpc-indicator').className = 'status-indicator status-offline';
                logger.error('RPC connection failed', error);
                return false;
            }
        }
        
        // Test 6: Create test token
        async function testCreateToken() {
            if (!wallet || !connection || !publicKey) {
                displayResult('token-result', 'Wallet not connected', 'error');
                return;
            }
            
            try {
                logger.info('Testing token creation...');
                updateTestStatus('Creating test token...');
                document.getElementById('create-token-btn').disabled = true;
                
                // Start transaction tracking
                const txId = 'create-token-' + Date.now();
                logger.startTransaction(txId, 'Token Creation');
                
                // 1. Generate keypair for mint
                logger.addTransactionStep(txId, 'Generate mint keypair', 'in_progress');
                const mint = solanaWeb3.Keypair.generate();
                logger.addTransactionStep(txId, 'Generate mint keypair', 'completed', { mint: mint.publicKey.toString() });
                
                // 2. Calculate rent
                logger.addTransactionStep(txId, 'Calculate rent', 'in_progress');
                const rentExemptBalance = await connection.getMinimumBalanceForRentExemption(splToken.MINT_SIZE);
                logger.addTransactionStep(txId, 'Calculate rent', 'completed', { rent: rentExemptBalance });
                
                // 3. Create token
                try {
                    logger.addTransactionStep(txId, 'Create mint account', 'in_progress');
                    
                    // Create mint account transaction
                    const transaction = new solanaWeb3.Transaction().add(
                        solanaWeb3.SystemProgram.createAccount({
                            fromPubkey: publicKey,
                            newAccountPubkey: mint.publicKey,
                            space: splToken.MINT_SIZE,
                            lamports: rentExemptBalance,
                            programId: splToken.TOKEN_PROGRAM_ID,
                        }),
                        splToken.createInitializeMintInstruction(
                            mint.publicKey,
                            9,  // 9 decimals
                            publicKey,
                            publicKey
                        )
                    );
                    
                    // Get blockhash
                    const { blockhash } = await connection.getLatestBlockhash();
                    transaction.recentBlockhash = blockhash;
                    transaction.feePayer = publicKey;
                    
                    // Sign with mint key
                    transaction.partialSign(mint);
                    
                    // Send to wallet for signing
                    const signed = await wallet.signTransaction(transaction);
                    
                    // Send transaction
                    const signature = await connection.sendRawTransaction(signed.serialize());
                    await connection.confirmTransaction(signature);
                    
                    logger.addTransactionStep(txId, 'Create mint account', 'completed', { signature });
                    
                    // Store mint for revocation test
                    testTokenMint = mint.publicKey;
                    
                    // Enable revocation test
                    document.getElementById('revoke-authority-btn').disabled = false;
                    
                    logger.success(`Test token created: ${mint.publicKey.toString()}`);
                    displayResult('token-result', `Token created successfully: ${mint.publicKey.toString()}`, 'success');
                    logger.completeTransaction(txId, 'success');
                } catch (error) {
                    logger.addTransactionStep(txId, 'Create mint account', 'error', { error: error.message });
                    logger.completeTransaction(txId, 'error', { error });
                    throw error;
                }
            } catch (error) {
                logger.error('Token creation test failed', error);
                displayResult('token-result', `Token creation failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('create-token-btn').disabled = false;
                completedTests++;
                updateProgressBar();
            }
        }
        
        // Test 7: Revoke authority
        async function testRevokeAuthority() {
            if (!wallet || !connection || !publicKey || !testTokenMint) {
                displayResult('revoke-result', 'Cannot test: No test token created', 'error');
                return;
            }
            
            try {
                logger.info('Testing authority revocation...');
                updateTestStatus('Revoking mint authority...');
                document.getElementById('revoke-authority-btn').disabled = true;
                
                // Start transaction tracking
                const txId = 'revoke-authority-' + Date.now();
                logger.startTransaction(txId, 'Authority Revocation');
                
                // Create revoke transaction
                logger.addTransactionStep(txId, 'Create revoke transaction', 'in_progress');
                
                const transaction = new solanaWeb3.Transaction().add(
                    splToken.createSetAuthorityInstruction(
                        testTokenMint,
                        publicKey,
                        splToken.AuthorityType.MintTokens,
                        null // Setting to null revokes it permanently
                    )
                );
                
                // Get blockhash
                const { blockhash } = await connection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = publicKey;
                
                logger.addTransactionStep(txId, 'Create revoke transaction', 'completed');
                
                try {
                    // Send to wallet for signing
                    logger.addTransactionStep(txId, 'Sign and send transaction', 'in_progress');
                    
                    const signed = await wallet.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());
                    await connection.confirmTransaction(signature);
                    
                    logger.addTransactionStep(txId, 'Sign and send transaction', 'completed', { signature });
                    
                    // Verify authority is revoked
                    logger.addTransactionStep(txId, 'Verify revocation', 'in_progress');
                    
                    const mintInfo = await splToken.getMint(connection, testTokenMint);
                    const isRevoked = mintInfo.mintAuthority === null;
                    
                    if (isRevoked) {
                        logger.addTransactionStep(txId, 'Verify revocation', 'completed');
                        logger.success('Authority successfully revoked');
                        displayResult('revoke-result', 'Authority successfully revoked', 'success');
                        logger.completeTransaction(txId, 'success');
                    } else {
                        logger.addTransactionStep(txId, 'Verify revocation', 'error', { mintAuthority: mintInfo.mintAuthority?.toString() });
                        throw new Error('Authority was not properly revoked');
                    }
                } catch (error) {
                    logger.addTransactionStep(txId, 'Revocation process', 'error', { error: error.message });
                    logger.completeTransaction(txId, 'error', { error });
                    throw error;
                }
            } catch (error) {
                logger.error('Authority revocation test failed', error);
                displayResult('revoke-result', `Revocation failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('revoke-authority-btn').disabled = false;
                completedTests++;
                updateProgressBar();
            }
        }
    </script>
</body>
</html>