<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SolMeme Creator - Professional Solana Token Creator</title>
    <meta name="description" content="Create professional Solana tokens with AI-generated images and real blockchain integration. Production-ready meme token creator with Phantom wallet support.">
    <meta name="keywords" content="Solana, token creator, meme token, cryptocurrency, blockchain, Phantom wallet, AI images">
    
    <!-- Production-ready Tailwind CSS -->
    <link rel="stylesheet" href="./css/tailwind.css">
    <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/spl-token@0.3.9/lib/index.iife.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Enhanced AI Image Generation System -->
    <script src="./ai-config.js"></script>
    <script src="./ai-image-generator.js"></script>
    <script src="./enhanced-ai-generator.js"></script>
    
    <style>
        /* ================================
         * MODERN CSS STYLES & DESIGN SYSTEM
         * ================================ */
        
        :root {
            /* Color Palette */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #fdbb2d 0%, #22c1c3 100%);
            --hero-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            
            /* Neutral Colors */
            --white: #ffffff;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-500: #6b7280;
            --gray-700: #374151;
            --gray-900: #111827;
            
            /* Spacing */
            --space-xs: 0.5rem;
            --space-sm: 1rem;
            --space-md: 1.5rem;
            --space-lg: 2rem;
            --space-xl: 3rem;
            --space-2xl: 4rem;
            
            /* Border Radius */
            --radius-sm: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --shadow-glow: 0 0 30px rgba(102, 126, 234, 0.3);
        }
        
        /* Base Styles */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: 100vh;
        }
        
        .hero-section {
            background: var(--hero-gradient);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            position: relative;
            overflow: hidden;
        }
        
        .hero-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('https://public.youware.com/users-website-assets/prod/1a7adfb7-e756-4c01-9d97-1ba0389e3d99/11a973821e924030ba923dd61d8ee726.png') center/cover;
            opacity: 0.1;
            mix-blend-mode: overlay;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .gradient-bg {
            background: var(--hero-gradient);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            position: relative;
            overflow: hidden;
        }
        
        .gradient-bg::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('https://public.youware.com/users-website-assets/prod/1a7adfb7-e756-4c01-9d97-1ba0389e3d99/11a973821e924030ba923dd61d8ee726.png') center/cover;
            opacity: 0.1;
            mix-blend-mode: overlay;
        }
        
        .card-shadow {
            box-shadow: var(--shadow-xl);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .card-shadow:hover {
            box-shadow: var(--shadow-xl), var(--shadow-glow);
            transform: translateY(-5px);
        }
        
        .pulse-dot {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            box-shadow: 0 0 8px currentColor;
        }
        
        .status-connected { 
            background: #10b981; 
            color: #10b981;
        }
        .status-connecting { 
            background: #f59e0b;
            color: #f59e0b;
        }
        .status-error { 
            background: #ef4444;
            color: #ef4444;
        }
        .status-disconnected { 
            background: #6b7280;
            color: #6b7280;
        }
        
        .mobile-responsive {
            transition: all 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .mobile-stack {
                flex-direction: column;
            }
            
            .mobile-full {
                width: 100%;
                margin-bottom: 1rem;
            }
        }
        
        .progress-bar {
            height: 6px;
            background: var(--primary-gradient);
            border-radius: 3px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .notification {
            transform: translateX(120%);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-xl);
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        /* Enhanced Button Styles */
        button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        button:not(:disabled):active {
            transform: translateY(0);
        }
        
        /* Loading Animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        .loading-spinner {
            border: 3px solid #f3f3f4;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        /* Feature Enhancement */
        .feature-icon {
            background: var(--primary-gradient);
            width: 5rem;
            height: 5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            margin: 0 auto 1.5rem;
            box-shadow: var(--shadow-lg);
            transition: all 0.3s ease;
        }
        
        .feature-icon:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-xl), var(--shadow-glow);
        }
        
        /* Team Card Enhancement */
        .team-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid var(--white);
            box-shadow: var(--shadow-lg);
            margin: 0 auto 1rem;
        }
        
        /* Text Gradient */
        .text-gradient {
            background: var(--primary-gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        
        /* Glass morphism effect */
        .glass-morphism {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        /* Floating animation */
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .float-animation {
            animation: float 3s ease-in-out infinite;
        }
        
        /* Fade in animation */
        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        /* Enhanced Animation Delays for AI Status */
        .animation-delay-200 {
            animation-delay: 0.2s;
        }
        
        .animation-delay-400 {
            animation-delay: 0.4s;
        }
        
        .animation-delay-600 {
            animation-delay: 0.6s;
        }
        
        .animation-delay-800 {
            animation-delay: 0.8s;
        }
        
        .fade-in-up {
            animation: fadeInUp 0.6s ease-out;
        }
        
        /* Improved hover effects */
        .hover-lift {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .hover-lift:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-xl), var(--shadow-glow);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    
    <!-- Enhanced Hero Header Section -->
    <header class="hero-section text-white py-16 shadow-xl relative z-10">
        <div class="container mx-auto px-4">
            <!-- Main Hero Content -->
            <div class="text-center mb-12">
                <div class="flex items-center justify-center space-x-4 mb-6">
                    <div class="feature-icon text-5xl">
                        <i class="fas fa-rocket"></i>
                    </div>
                    <div>
                        <h1 class="text-5xl lg:text-6xl font-extrabold mb-2">
                            <span class="text-gradient">SolMeme</span> Creator
                        </h1>
                        <p class="text-2xl opacity-90 font-medium">Professional Solana Token Creator</p>
                    </div>
                </div>
                
                <!-- Enhanced Value Proposition -->
                <div class="max-w-4xl mx-auto mb-8">
                    <p class="text-xl opacity-90 mb-4 leading-relaxed">
                        Create unique meme tokens with <strong>AI-powered image generation</strong> and <strong>professional Solana deployment</strong>
                    </p>
                    <div class="flex flex-wrap justify-center gap-4 text-sm opacity-80">
                        <span class="bg-white bg-opacity-20 px-4 py-2 rounded-full">
                            <i class="fas fa-robot mr-2"></i>4 AI Providers
                        </span>
                        <span class="bg-white bg-opacity-20 px-4 py-2 rounded-full">
                            <i class="fas fa-shield-alt mr-2"></i>Security Audited
                        </span>
                        <span class="bg-white bg-opacity-20 px-4 py-2 rounded-full">
                            <i class="fas fa-bolt mr-2"></i>Lightning Fast
                        </span>
                        <span class="bg-white bg-opacity-20 px-4 py-2 rounded-full">
                            <i class="fas fa-globe mr-2"></i>Free Promo Websites
                        </span>
                    </div>
                </div>

                <!-- Primary CTA -->
                <div class="mb-8">
                    <a href="#tokenCreationSection" class="inline-block bg-white text-purple-600 px-12 py-4 rounded-2xl font-bold text-xl hover:bg-gray-100 transition-all transform hover:scale-105 shadow-xl">
                        <i class="fas fa-magic mr-3"></i>Start Creating Tokens
                        <span class="ml-2 text-sm opacity-75">‚Üí</span>
                    </a>
                    <p class="text-sm opacity-75 mt-3">No registration required ‚Ä¢ Connect wallet to begin</p>
                </div>
            </div>

            <!-- Wallet Status Bar -->
            <div class="flex flex-col lg:flex-row justify-between items-center mobile-responsive bg-white bg-opacity-10 rounded-2xl p-6">
                <div class="flex items-center space-x-6 mobile-full mb-4 lg:mb-0">
                    <!-- Network Status -->
                    <div class="flex items-center text-sm opacity-90">
                        <div class="w-3 h-3 bg-green-400 rounded-full mr-2 animate-pulse"></div>
                        <span>Solana Mainnet Connected</span>
                    </div>
                    
                    <!-- Wallet Status -->
                    <div id="walletStatus" class="flex items-center text-sm opacity-90">
                        <span class="status-indicator status-disconnected pulse-dot" id="walletIndicator"></span>
                        <span id="walletStatusText">Wallet Disconnected</span>
                    </div>
                    
                    <!-- Balance Display -->
                    <div class="text-center lg:text-left">
                        <div id="solBalance" class="text-lg font-bold">0.000000 SOL</div>
                        <div class="text-xs opacity-75">Available Balance</div>
                    </div>
                </div>
                
                <!-- Enhanced Wallet Buttons -->
                <div class="flex space-x-3">
                    <button id="connectWallet" class="bg-white text-purple-600 px-8 py-3 rounded-xl font-bold hover:bg-gray-100 transition-all transform hover:scale-105 shadow-lg">
                        <i class="fas fa-wallet mr-2"></i>Connect Phantom
                    </button>
                    <button id="disconnectWallet" class="hidden bg-red-500 text-white px-8 py-3 rounded-xl font-bold hover:bg-red-600 transition-all shadow-lg">
                        <i class="fas fa-sign-out-alt mr-2"></i>Disconnect
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-12">
        
        <!-- Enhanced Network Status Card -->
        <div class="card-shadow rounded-2xl p-8 mb-12 fade-in-up">
            <div class="flex flex-col lg:flex-row justify-between items-center mobile-responsive">
                <div class="flex items-center mb-6 lg:mb-0">
                    <div class="feature-icon mr-4" style="width: 3rem; height: 3rem; font-size: 1.2rem;">
                        <i class="fab fa-solana"></i>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-gray-800">Solana Mainnet</h3>
                        <p class="text-gray-600">High-performance blockchain network</p>
                    </div>
                </div>
                <div class="text-center lg:text-right">
                    <div id="rpcStatus" class="text-lg font-semibold text-yellow-600 mb-2">Status: Connecting...</div>
                    <div id="currentRpc" class="text-sm text-gray-500">Endpoint: Initializing...</div>
                    <div id="blockHeight" class="text-sm text-gray-500">Block: Loading...</div>
                </div>
            </div>
        </div>

        <!-- Enhanced Features Section -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8 mb-16">
            <div class="card-shadow rounded-2xl p-8 text-center hover-lift fade-in-up">
                <div class="feature-icon">
                    <i class="fas fa-shield-alt"></i>
                </div>
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Secure & Safe</h3>
                <p class="text-gray-600 leading-relaxed">All transactions are verified on Solana blockchain with enterprise-grade security and real-time monitoring.</p>
            </div>
            
            <div class="card-shadow rounded-2xl p-8 text-center hover-lift fade-in-up" style="animation-delay: 0.2s;">
                <div class="feature-icon">
                    <i class="fas fa-bolt"></i>
                </div>
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Lightning Fast</h3>
                <p class="text-gray-600 leading-relaxed">Deploy tokens in seconds with Solana's high-performance network and instant transaction confirmations.</p>
            </div>
            
            <div class="card-shadow rounded-2xl p-8 text-center hover-lift fade-in-up" style="animation-delay: 0.4s;">
                <div class="feature-icon">
                    <i class="fas fa-dollar-sign"></i>
                </div>
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Low Cost</h3>
                <p class="text-gray-600 leading-relaxed">Minimal network fees with no hidden platform charges. Create professional tokens affordably.</p>
            </div>
        </div>

        <!-- Enhanced Team Section with Trust Indicators -->
        <div class="card-shadow rounded-2xl p-12 mb-16 fade-in-up">
            <div class="text-center mb-12">
                <h2 class="text-4xl font-bold text-gray-800 mb-4">Meet Our <span class="text-gradient">Expert Team</span></h2>
                <p class="text-xl text-gray-600 max-w-3xl mx-auto">Blockchain professionals dedicated to bringing you the most advanced token creation platform on Solana.</p>
                <!-- Trust Indicators -->
                <div class="flex justify-center items-center gap-8 mt-8 text-sm text-gray-500">
                    <div class="flex items-center">
                        <i class="fas fa-shield-alt text-green-500 mr-2"></i>
                        <span>Security Audited</span>
                    </div>
                    <div class="flex items-center">
                        <i class="fas fa-university text-blue-500 mr-2"></i>
                        <span>Industry Veterans</span>
                    </div>
                    <div class="flex items-center">
                        <i class="fas fa-certificate text-purple-500 mr-2"></i>
                        <span>Blockchain Certified</span>
                    </div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                <!-- Sarah Chen - Blockchain Lead -->
                <div class="text-center hover-lift group">
                    <div class="relative mb-6">
                        <img src="https://public.youware.com/users-website-assets/prod/1a7adfb7-e756-4c01-9d97-1ba0389e3d99/e9fa38da9fdc48099965a2ecb94f7a6a.jpg" alt="Sarah Chen - Blockchain Lead" class="team-avatar group-hover:scale-105 transition-transform duration-300">
                        <div class="absolute -bottom-2 -right-2 w-8 h-8 bg-green-500 rounded-full flex items-center justify-center">
                            <i class="fas fa-check text-white text-sm"></i>
                        </div>
                    </div>
                    <h4 class="text-xl font-bold text-gray-800 mb-2">Sarah Chen</h4>
                    <p class="text-purple-600 font-semibold mb-3">Blockchain Lead</p>
                    <p class="text-gray-600 text-sm mb-4">Former Solana Labs engineer with 5+ years in DeFi protocol development and smart contract security.</p>
                    <div class="flex justify-center space-x-4 text-xs text-gray-500">
                        <span class="bg-gray-100 px-2 py-1 rounded">Solana Expert</span>
                        <span class="bg-gray-100 px-2 py-1 rounded">DeFi</span>
                        <span class="bg-gray-100 px-2 py-1 rounded">Security</span>
                    </div>
                </div>
                
                <!-- Marcus Rodriguez - AI Specialist -->
                <div class="text-center hover-lift group">
                    <div class="relative mb-6">
                        <img src="https://public.youware.com/users-website-assets/prod/1a7adfb7-e756-4c01-9d97-1ba0389e3d99/c0fc174078e14218b5bb6d702670a3bd.jpg" alt="Marcus Rodriguez - AI Specialist" class="team-avatar group-hover:scale-105 transition-transform duration-300">
                        <div class="absolute -bottom-2 -right-2 w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                            <i class="fas fa-robot text-white text-sm"></i>
                        </div>
                    </div>
                    <h4 class="text-xl font-bold text-gray-800 mb-2">Marcus Rodriguez</h4>
                    <p class="text-purple-600 font-semibold mb-3">AI Specialist</p>
                    <p class="text-gray-600 text-sm mb-4">Machine learning expert specializing in generative AI for creative content and automated design systems.</p>
                    <div class="flex justify-center space-x-4 text-xs text-gray-500">
                        <span class="bg-gray-100 px-2 py-1 rounded">AI/ML</span>
                        <span class="bg-gray-100 px-2 py-1 rounded">CLIP</span>
                        <span class="bg-gray-100 px-2 py-1 rounded">Computer Vision</span>
                    </div>
                </div>
                
                <!-- Elena Petrov - Security Expert -->
                <div class="text-center hover-lift group">
                    <div class="relative mb-6">
                        <img src="https://public.youware.com/users-website-assets/prod/1a7adfb7-e756-4c01-9d97-1ba0389e3d99/0b926ea5b1314e89864d618f358f13d8.jpg" alt="Elena Petrov - Security Expert" class="team-avatar group-hover:scale-105 transition-transform duration-300">
                        <div class="absolute -bottom-2 -right-2 w-8 h-8 bg-red-500 rounded-full flex items-center justify-center">
                            <i class="fas fa-shield-alt text-white text-sm"></i>
                        </div>
                    </div>
                    <h4 class="text-xl font-bold text-gray-800 mb-2">Elena Petrov</h4>
                    <p class="text-purple-600 font-semibold mb-3">Security Expert</p>
                    <p class="text-gray-600 text-sm mb-4">Cybersecurity specialist ensuring robust protection for all transactions and user data privacy.</p>
                    <div class="flex justify-center space-x-4 text-xs text-gray-500">
                        <span class="bg-gray-100 px-2 py-1 rounded">Cybersecurity</span>
                        <span class="bg-gray-100 px-2 py-1 rounded">Risk Management</span>
                        <span class="bg-gray-100 px-2 py-1 rounded">Compliance</span>
                    </div>
                </div>
            </div>

            <!-- Additional Trust Elements -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-12 pt-8 border-t border-gray-200">
                <div class="text-center">
                    <div class="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
                        <i class="fas fa-users text-green-600 text-2xl"></i>
                    </div>
                    <h5 class="font-semibold text-gray-800 mb-2">50,000+ Users</h5>
                    <p class="text-sm text-gray-600">Trusted by crypto enthusiasts worldwide</p>
                </div>
                <div class="text-center">
                    <div class="w-16 h-16 bg-purple-100 rounded-full flex items-center justify-center mx-auto mb-4">
                        <i class="fas fa-coins text-purple-600 text-2xl"></i>
                    </div>
                    <h5 class="font-semibold text-gray-800 mb-2">500,000+ Tokens</h5>
                    <p class="text-sm text-gray-600">Successfully deployed on Solana</p>
                </div>
                <div class="text-center">
                    <div class="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-4">
                        <i class="fas fa-clock text-blue-600 text-2xl"></i>
                    </div>
                    <h5 class="font-semibold text-gray-800 mb-2">99.9% Uptime</h5>
                    <p class="text-sm text-gray-600">Enterprise-grade reliability</p>
                </div>
            </div>
        </div>

        <!-- Wallet Information Section -->
        <div id="walletInfo" class="hidden card-shadow rounded-2xl p-8 mb-12 fade-in-up">
            <div class="text-center mb-8">
                <h2 class="text-3xl font-bold text-gray-800 mb-4">Wallet Connected</h2>
                <div class="glass-morphism rounded-xl p-6 inline-block">
                    <p class="text-sm text-gray-600 mb-2">Connected Address</p>
                    <input type="text" id="walletAddress" readonly class="bg-transparent text-center text-lg font-mono text-gray-800 border-none outline-none w-full" placeholder="Wallet address will appear here">
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div class="text-center p-6 glass-morphism rounded-xl">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Current Balance</h3>
                    <p id="detailedBalance" class="text-2xl font-bold text-purple-600">0.000000 SOL</p>
                    <p id="balanceTimestamp" class="text-xs text-gray-500 mt-2">Last updated: Never</p>
                </div>
                
                <div class="text-center p-6 glass-morphism rounded-xl">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Network Fee</h3>
                    <p id="networkFee" class="text-2xl font-bold text-blue-600">~0.015 SOL</p>
                    <p class="text-xs text-gray-500 mt-2">Est. transaction cost</p>
                </div>
                
                <div class="text-center p-6 glass-morphism rounded-xl">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Status</h3>
                    <p class="text-2xl font-bold text-green-600">Ready</p>
                    <p class="text-xs text-gray-500 mt-2">Ready to create tokens</p>
                </div>
            </div>
        </div>

        <!-- Enhanced Token Creation Section -->
        <div id="tokenCreationSection" class="scroll-mt-8">
            <!-- Enhanced Mode Selection with AI Focus -->
            <div class="card-shadow rounded-2xl p-8 mb-8 fade-in-up">
                <div class="text-center mb-8">
                    <h2 class="text-4xl font-bold text-gray-800 mb-4">
                        Choose Your <span class="text-gradient">Creation Method</span>
                    </h2>
                    <p class="text-xl text-gray-600 max-w-2xl mx-auto">
                        Experience the future of meme token creation with our enhanced AI system
                    </p>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 max-w-4xl mx-auto">
                    <!-- AI-Powered Creation (Featured) -->
                    <div class="relative">
                        <!-- Recommended Badge -->
                        <div class="absolute -top-4 left-1/2 transform -translate-x-1/2 z-10">
                            <span class="bg-gradient-to-r from-purple-600 to-pink-600 text-white px-6 py-2 rounded-full text-sm font-bold shadow-lg">
                                <i class="fas fa-star mr-2"></i>RECOMMENDED
                            </span>
                        </div>
                        
                        <button id="aiModeBtn" class="w-full p-8 glass-morphism rounded-xl hover-lift text-center transition-all duration-300 border-2 border-purple-300 bg-gradient-to-br from-purple-50 to-pink-50 group">
                            <div class="text-6xl mb-6 text-purple-600 group-hover:scale-110 transition-transform">
                                <i class="fas fa-magic"></i>
                            </div>
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">AI-Powered Creation</h3>
                            <p class="text-gray-600 mb-6 leading-relaxed">
                                Let our enhanced AI generate your token with smart suggestions and automated image creation using 4 AI providers
                            </p>
                            
                            <!-- AI Features -->
                            <div class="bg-white bg-opacity-50 rounded-lg p-4 mb-6">
                                <div class="grid grid-cols-2 gap-4 text-sm">
                                    <div class="flex items-center">
                                        <i class="fas fa-robot text-purple-500 mr-2"></i>
                                        <span>4 AI Providers</span>
                                    </div>
                                    <div class="flex items-center">
                                        <i class="fas fa-eye text-purple-500 mr-2"></i>
                                        <span>CLIP Matching</span>
                                    </div>
                                    <div class="flex items-center">
                                        <i class="fas fa-sync text-purple-500 mr-2"></i>
                                        <span>Auto-Regen</span>
                                    </div>
                                    <div class="flex items-center">
                                        <i class="fas fa-trophy text-purple-500 mr-2"></i>
                                        <span>Perfect Results</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="font-bold text-purple-600 text-lg">
                                Perfect for First-Time Creators
                            </div>
                        </button>
                    </div>
                    
                    <!-- Manual Creation -->
                    <button id="manualModeBtn" class="p-8 glass-morphism rounded-xl hover-lift text-center transition-all duration-300 border-2 border-gray-200 group">
                        <div class="text-4xl mb-6 text-gray-600 group-hover:text-purple-600 transition-colors">
                            <i class="fas fa-cogs"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-4">Manual Creation</h3>
                        <p class="text-gray-600 mb-6 leading-relaxed">
                            Full control over every aspect of your token with custom parameters and manual image upload
                        </p>
                        
                        <!-- Manual Features -->
                        <div class="bg-gray-50 rounded-lg p-4 mb-6">
                            <div class="grid grid-cols-2 gap-4 text-sm text-gray-600">
                                <div class="flex items-center">
                                    <i class="fas fa-sliders-h text-gray-500 mr-2"></i>
                                    <span>Custom Controls</span>
                                </div>
                                <div class="flex items-center">
                                    <i class="fas fa-upload text-gray-500 mr-2"></i>
                                    <span>Image Upload</span>
                                </div>
                                <div class="flex items-center">
                                    <i class="fas fa-edit text-gray-500 mr-2"></i>
                                    <span>Manual Fields</span>
                                </div>
                                <div class="flex items-center">
                                    <i class="fas fa-user text-gray-500 mr-2"></i>
                                    <span>Expert Mode</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-bold text-gray-600">
                            For Advanced Users
                        </div>
                    </button>
                </div>
            </div>

            <!-- AI Mode Panel -->
            <div id="aiMode" class="card-shadow rounded-2xl p-8 mb-8 fade-in-up">
                <h3 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-robot mr-3 text-purple-600"></i>
                    AI Token Generator
                </h3>
                
                <div class="mb-6">
                    <label for="aiTheme" class="block text-sm font-semibold text-gray-700 mb-3">
                        <i class="fas fa-magic text-purple-500 mr-2"></i>Describe Your Perfect Meme Token
                    </label>
                    <div class="bg-gradient-to-r from-purple-50 to-pink-50 border border-purple-200 rounded-lg p-4 mb-3">
                        <h5 class="text-sm font-semibold text-purple-700 mb-2">üéØ AI Enhancement Features:</h5>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs text-purple-600">
                            <div><i class="fas fa-robot text-purple-500 mr-1"></i>4 AI Providers: DALL¬∑E, Midjourney, Flux, Stable Diffusion</div>
                            <div><i class="fas fa-eye text-purple-500 mr-1"></i>CLIP Similarity Matching for perfect results</div>
                            <div><i class="fas fa-sync text-purple-500 mr-1"></i>Auto-regeneration if quality is below 75%</div>
                            <div><i class="fas fa-trophy text-purple-500 mr-1"></i>Guaranteed funny, unique meme images</div>
                        </div>
                    </div>
                    <textarea id="aiTheme" 
                              placeholder="Be as creative and specific as possible! The more details, the better your image:

üé® AMAZING Examples:
‚Ä¢ A space cat wearing astronaut suit with laser eyes, flying rocket ship through colorful galaxy
‚Ä¢ A ninja duck chef making sushi in futuristic neon kitchen with holographic ingredients
‚Ä¢ A robot hamster with LED wheels running in cryptocurrency mining facility with golden coins
‚Ä¢ A dancing taco mascot with rainbow filling, wearing sunglasses, on stage with spotlights
‚Ä¢ A cyberpunk penguin in leather jacket surfing digital waves in virtual reality ocean
‚Ä¢ A superhero banana in cape flying over city skyline with muscular arms flexing
‚Ä¢ A wise owl CEO in business suit sitting at mahogany desk with stock charts floating around

üí° TIP: Include WHO (animal/character), WHAT (action), WHERE (setting), and STYLE (mood/theme)" 
                              class="w-full px-4 py-4 border border-purple-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent resize-none text-sm" 
                              rows="8" 
                              maxlength="500"></textarea>
                    <div class="flex justify-between items-center mt-2">
                        <div class="flex items-center space-x-4">
                            <p class="text-xs text-purple-600 font-medium">
                                <i class="fas fa-sparkles text-purple-500 mr-1"></i>
                                Enhanced AI will analyze your concept and create the perfect mascot!
                            </p>
                            <div class="flex items-center space-x-1">
                                <div class="w-2 h-2 bg-green-400 rounded-full"></div>
                                <span class="text-xs text-green-600 font-medium">AI System Active</span>
                            </div>
                        </div>
                        <span id="conceptCharCount" class="text-xs font-medium" style="color: #8B5CF6;">0 / 500</span>
                    </div>
                    <div class="mt-2 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                        <p class="text-xs text-yellow-700">
                            <i class="fas fa-lightbulb text-yellow-500 mr-1"></i>
                            <strong>Pro Tip:</strong> More detailed descriptions = better images! Include personality, colors, setting, and mood for amazing results.
                        </p>
                    </div>
                </div>
                
                <div class="flex justify-center mb-6">
                    <button id="generateAI" class="bg-gradient-to-r from-purple-600 to-pink-600 text-white px-8 py-4 rounded-xl font-bold hover:from-purple-700 hover:to-pink-700 transition-all transform hover:scale-105 shadow-lg text-lg relative overflow-hidden">
                        <div class="relative z-10 flex items-center">
                            <i class="fas fa-magic mr-3 text-xl"></i>
                            <span>Generate Perfect Meme Token</span>
                            <i class="fas fa-rocket ml-3 text-xl"></i>
                        </div>
                        <div class="absolute inset-0 bg-gradient-to-r from-pink-600 to-purple-600 opacity-0 hover:opacity-100 transition-opacity duration-300"></div>
                    </button>
                </div>
                <div class="text-center mb-6">
                    <p class="text-sm text-gray-600">
                        <i class="fas fa-shield-alt text-green-500 mr-1"></i>
                        100% Unique Images ‚Ä¢ No Generic Stock Photos ‚Ä¢ Perfect Token Mascots
                    </p>
                </div>
                
                <!-- Enhanced Loading Indicator -->
                <div id="aiGenerationLoader" class="hidden text-center py-8">
                    <div class="relative mb-6">
                        <div class="loading-spinner mx-auto mb-4"></div>
                        <div class="absolute inset-0 flex items-center justify-center">
                            <div class="w-16 h-16 border-4 border-purple-200 border-t-purple-600 rounded-full animate-spin"></div>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <h4 class="text-lg font-bold text-purple-700">ü§ñ Enhanced AI Generation in Progress</h4>
                        <div id="aiGenerationStatus" class="text-sm text-gray-600">
                            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4 max-w-md mx-auto">
                                <div class="space-y-2">
                                    <div class="flex items-center">
                                        <div class="w-2 h-2 bg-purple-500 rounded-full mr-3 animate-pulse"></div>
                                        <span>Analyzing your concept with AI...</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-2 h-2 bg-blue-500 rounded-full mr-3 animate-pulse animation-delay-200"></div>
                                        <span>Generating images from 4 AI providers...</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-2 h-2 bg-green-500 rounded-full mr-3 animate-pulse animation-delay-400"></div>
                                        <span>Using CLIP to find perfect match...</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-2 h-2 bg-pink-500 rounded-full mr-3 animate-pulse animation-delay-600"></div>
                                        <span>Creating your unique meme token...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p class="text-xs text-gray-500">
                            ‚è±Ô∏è This may take 30-60 seconds for the best quality results
                        </p>
                    </div>
                </div>
                
                <!-- Enhanced AI Preview -->
                <div id="aiPreview" class="hidden p-6 glass-morphism rounded-xl">
                    <div class="text-center mb-6">
                        <h3 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-pink-600 mb-2">
                            üéâ Perfect Meme Token Created!
                        </h3>
                        <p class="text-sm text-gray-600">Enhanced AI has generated your unique token with perfect image matching</p>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <!-- Image Section -->
                        <div class="text-center">
                            <h4 class="text-lg font-semibold text-gray-700 mb-4">
                                <i class="fas fa-crown text-yellow-500 mr-2"></i>Your Unique AI Mascot
                            </h4>
                            <div id="aiTokenImage" class="relative w-72 h-72 mx-auto bg-gradient-to-br from-purple-100 to-blue-100 rounded-xl flex items-center justify-center border-2 border-dashed border-purple-300 overflow-hidden">
                                <div class="text-center">
                                    <i class="fas fa-magic text-4xl text-purple-400 mb-2"></i>
                                    <p class="text-sm text-purple-600 font-medium">Enhanced AI Mascot</p>
                                    <p class="text-xs text-purple-500">Generated with 4 AI providers</p>
                                </div>
                            </div>
                            
                            <!-- AI Generation Stats -->
                            <div id="aiImageStats" class="mt-4 hidden">
                                <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm">
                                    <div class="grid grid-cols-2 gap-3 text-xs">
                                        <div class="text-center">
                                            <div class="font-semibold text-gray-700" id="aiProvider">Provider</div>
                                            <div class="text-gray-500">Generator</div>
                                        </div>
                                        <div class="text-center">
                                            <div class="font-semibold text-green-600" id="aiSimilarity">95%</div>
                                            <div class="text-gray-500">Match Score</div>
                                        </div>
                                    </div>
                                    <div class="mt-2 pt-2 border-t border-gray-200">
                                        <div class="text-xs text-gray-600" id="aiPromptPreview">Enhanced prompt used...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Token Details Section -->
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-4">
                                <i class="fas fa-coins text-yellow-500 mr-2"></i>Token Details
                            </h4>
                            <div class="space-y-4">
                                <div class="bg-white border border-gray-200 rounded-lg p-4">
                                    <div class="space-y-3">
                                        <div>
                                            <label class="text-sm font-medium text-gray-600">Token Name</label>
                                            <div id="aiTokenName" class="text-lg font-bold text-gray-800">Generated Token</div>
                                        </div>
                                        <div>
                                            <label class="text-sm font-medium text-gray-600">Symbol</label>
                                            <div id="aiTokenSymbol" class="text-lg font-bold text-purple-600">TOKEN</div>
                                        </div>
                                        <div>
                                            <label class="text-sm font-medium text-gray-600">Description</label>
                                            <div id="aiTokenDescription" class="text-sm text-gray-700">AI generated meme token description</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="bg-gradient-to-r from-green-50 to-blue-50 border border-green-200 rounded-lg p-4">
                                    <h5 class="text-sm font-semibold text-green-700 mb-2">‚úÖ Quality Guarantees</h5>
                                    <div class="space-y-1 text-xs text-green-600">
                                        <div><i class="fas fa-check text-green-500 mr-1"></i>100% unique, never-before-seen image</div>
                                        <div><i class="fas fa-check text-green-500 mr-1"></i>Perfect mascot for meme token branding</div>
                                        <div><i class="fas fa-check text-green-500 mr-1"></i>Optimized for social media sharing</div>
                                        <div><i class="fas fa-check text-green-500 mr-1"></i>Professional quality, ready for exchanges</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="flex justify-center gap-4 mt-8">
                        <button id="regenerateAI" class="bg-gray-500 text-white px-6 py-2 rounded-lg hover:bg-gray-600 transition-colors">
                            <i class="fas fa-sync mr-2"></i>Generate New
                        </button>
                        <button id="createAIToken" class="bg-gradient-to-r from-green-600 to-blue-600 text-white px-8 py-2 rounded-lg font-bold hover:from-green-700 hover:to-blue-700 transition-all transform hover:scale-105">
                            <i class="fas fa-rocket mr-2"></i>Create This Token
                        </button>
                    </div>
                    
                    <div class="mt-4 text-center">
                        <div class="flex justify-center gap-1">
                                <span class="bg-purple-100 text-purple-700 px-2 py-0.5 rounded-full text-xs">üîí Unique Seed</span>
                                <span class="bg-red-100 text-red-700 px-2 py-0.5 rounded-full text-xs">üö´ No Stock</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h4 class="text-lg font-semibold text-gray-700 mb-4">Token Details</h4>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Name</label>
                                <p id="aiTokenName" class="text-lg font-bold text-gray-800">-</p>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Symbol</label>
                                <p id="aiTokenSymbol" class="text-lg font-bold text-purple-600">-</p>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Description</label>
                                <p id="aiTokenDescription" class="text-gray-700">-</p>
                            </div>
                            <div class="grid grid-cols-2 gap-4 mt-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-600 mb-1">Supply</label>
                                    <input type="number" id="aiTokenSupply" value="1000000000" min="1" max="999999999999999999" 
                                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-600 mb-1">Decimals</label>
                                    <input type="number" id="aiTokenDecimals" value="9" min="0" max="9" 
                                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm">
                                </div>
                            </div>
                            <div class="mt-4">
                                <label class="block text-sm font-medium text-gray-600 mb-2">Authority Settings</label>
                                <div class="space-y-2 bg-gray-50 p-3 rounded-lg">
                                    <div class="flex items-center">
                                        <input type="checkbox" id="aiRevokeMintAuthority" class="mr-2 h-3 w-3 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
                                        <label for="aiRevokeMintAuthority" class="text-xs text-gray-700">Revoke Mint Authority</label>
                                    </div>
                                    <div class="flex items-center">
                                        <input type="checkbox" id="aiRevokeFreezeAuthority" class="mr-2 h-3 w-3 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
                                        <label for="aiRevokeFreezeAuthority" class="text-xs text-gray-700">Revoke Freeze Authority</label>
                                    </div>
                                    <div class="flex items-center">
                                        <input type="checkbox" id="aiRevokeUpdateAuthority" class="mr-2 h-3 w-3 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
                                        <label for="aiRevokeUpdateAuthority" class="text-xs text-gray-700">Revoke Update Authority</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="createAIToken" class="w-full mt-6 bg-gradient-to-r from-green-500 to-blue-500 text-white px-6 py-3 rounded-xl font-bold hover:from-green-600 hover:to-blue-600 transition-all shadow-lg">
                            <i class="fas fa-rocket mr-2"></i>Create This Token
                        </button>
                    </div>
                </div>
            </div>

            <!-- Manual Mode Panel -->
            <div id="manualMode" class="hidden card-shadow rounded-2xl p-8 mb-8 fade-in-up">
                <h3 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-tools mr-3 text-blue-600"></i>
                    Manual Token Creation
                </h3>
                
                <!-- Auto-Generate Button -->
                <div class="mb-6 text-center">
                    <button id="autoGenerateFields" class="bg-gradient-to-r from-emerald-500 to-teal-500 text-white px-6 py-3 rounded-xl font-bold hover:from-emerald-600 hover:to-teal-600 transition-all transform hover:scale-105 shadow-lg">
                        <i class="fas fa-magic mr-2"></i>Auto-Generate Unique Token Details
                    </button>
                    <p class="text-xs text-gray-500 mt-2">Click to automatically generate unique name, symbol, and description</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div class="space-y-6">
                        <div>
                            <label for="manualTokenName" class="block text-sm font-semibold text-gray-700 mb-2">
                                Token Name 
                                <span class="text-red-500">*</span>
                            </label>
                            <input type="text" id="manualTokenName" placeholder="e.g., My Awesome Token" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" maxlength="32">
                            <div id="nameValidation" class="mt-1 text-xs"></div>
                        </div>
                        
                        <div>
                            <label for="manualTokenSymbol" class="block text-sm font-semibold text-gray-700 mb-2">
                                Token Symbol
                                <span class="text-red-500">*</span>
                            </label>
                            <input type="text" id="manualTokenSymbol" placeholder="e.g., MAT" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent uppercase" maxlength="10">
                            <div id="symbolValidation" class="mt-1 text-xs"></div>
                        </div>
                        
                        <div>
                            <label for="manualTokenDescription" class="block text-sm font-semibold text-gray-700 mb-2">
                                Description (minimum 50 characters)
                                <span class="text-red-500">*</span>
                            </label>
                            <textarea id="manualTokenDescription" placeholder="Describe your token's purpose and features in detail to ensure uniqueness..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none" rows="4" maxlength="1000"></textarea>
                            <div id="descriptionValidation" class="mt-1 text-xs"></div>
                            <div id="descriptionCounter" class="mt-1 text-xs text-gray-500">0 / 50 characters minimum</div>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label for="tokenSupply" class="block text-sm font-semibold text-gray-700 mb-2">
                                    Total Supply
                                    <span class="text-red-500">*</span>
                                </label>
                                <input type="number" 
                                       id="tokenSupply" 
                                       placeholder="1000000000" 
                                       value="1000000000"
                                       min="1" 
                                       max="999999999999999999" 
                                       class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" 
                                       required>
                                <p class="text-xs text-gray-500 mt-1">Total number of tokens to mint (default: 1,000,000,000)</p>
                            </div>
                            
                            <div>
                                <label for="tokenDecimals" class="block text-sm font-semibold text-gray-700 mb-2">
                                    Decimals
                                    <span class="text-red-500">*</span>
                                </label>
                                <input type="number" 
                                       id="tokenDecimals" 
                                       placeholder="9" 
                                       value="9"
                                       min="0" 
                                       max="9" 
                                       class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" 
                                       required>
                                <p class="text-xs text-gray-500 mt-1">Number of decimal places (0-9, default: 9)</p>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-3">Authority Settings</label>
                            <div class="space-y-3 bg-gray-50 p-4 rounded-lg">
                                <div class="flex items-center">
                                    <input type="checkbox" id="revokeMintAuthority" class="mr-3 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                    <label for="revokeMintAuthority" class="text-sm text-gray-700">
                                        <span class="font-medium">Revoke Mint Authority</span>
                                        <span class="block text-xs text-gray-500">Prevents creating additional tokens after deployment</span>
                                    </label>
                                </div>
                                
                                <div class="flex items-center">
                                    <input type="checkbox" id="revokeFreezeAuthority" class="mr-3 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                    <label for="revokeFreezeAuthority" class="text-sm text-gray-700">
                                        <span class="font-medium">Revoke Freeze Authority</span>
                                        <span class="block text-xs text-gray-500">Prevents freezing/unfreezing token accounts</span>
                                    </label>
                                </div>
                                
                                <div class="flex items-center">
                                    <input type="checkbox" id="revokeUpdateAuthority" class="mr-3 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                    <label for="revokeUpdateAuthority" class="text-sm text-gray-700">
                                        <span class="font-medium">Revoke Update Authority</span>
                                        <span class="block text-xs text-gray-500">Prevents modifying token metadata after deployment</span>
                                    </label>
                                </div>
                                
                                <div class="mt-3 p-3 bg-blue-50 border border-blue-200 rounded">
                                    <p class="text-xs text-blue-700">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        <strong>Recommended:</strong> Check all options for maximum decentralization and trust. 
                                        Once revoked, these authorities cannot be restored.
                                    </p>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <label for="transactionFeePercentage" class="block text-sm font-semibold text-gray-700 mb-2">
                                Transaction Fee Percentage (0% to 5%)
                                <span class="text-red-500">*</span>
                            </label>
                            <div class="relative">
                                <input type="number" 
                                       id="transactionFeePercentage" 
                                       placeholder="0.0" 
                                       value="0.0"
                                       min="0" 
                                       max="5" 
                                       step="0.1" 
                                       class="w-full px-4 py-3 pr-8 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" 
                                       required>
                                <span class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 text-sm">%</span>
                            </div>
                            <p class="text-xs text-gray-500 mt-2">
                                Enter the fee percentage for Token22 Transfer Hook (0% for no fees, increments of 0.1%). Example: 0%, 1.5%, 2.0%
                            </p>
                            <div id="feeError" class="hidden text-red-500 text-sm mt-1">
                                <i class="fas fa-exclamation-triangle mr-1"></i>
                                Fee must be between 0.0% and 5.0% in 0.1% increments
                            </div>
                            <div id="feeConfirmation" class="hidden bg-blue-50 border border-blue-200 rounded-lg p-3 mt-3">
                                <div class="flex items-start">
                                    <i class="fas fa-info-circle text-blue-500 mt-0.5 mr-2"></i>
                                    <div class="text-sm text-blue-700">
                                        <strong>Fee Confirmation:</strong> You have chosen a <span id="feeDisplayValue">0.0</span>% transaction fee. 
                                        <span id="feeDescription">No fees will be charged on transfers.</span>
                                    </div>
                                </div>
                            </div>
                            <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mt-3">
                                <div class="flex items-start">
                                    <i class="fas fa-lightbulb text-yellow-500 mt-0.5 mr-2"></i>
                                    <div class="text-sm text-yellow-700">
                                        <strong>Token22 Transfer Hook:</strong> This uses Solana's Token22 program with Transfer Hook extension for real on-chain fees. 
                                        If you set 0%, the token will have no transfer fees and use standard SPL token functionality.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="feeCollectorSection" class="hidden">
                            <label for="feeCollectorWallet" class="block text-sm font-semibold text-gray-700 mb-2">
                                Fee Collector Wallet Address
                                <span class="text-red-500">*</span>
                            </label>
                            <div class="relative">
                                <input type="text" 
                                       id="feeCollectorWallet" 
                                       placeholder="Enter wallet address to receive fees (defaults to your wallet)" 
                                       class="w-full px-4 py-3 pr-12 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" 
                                       maxlength="44">
                                <button type="button" 
                                        id="useMyWalletBtn" 
                                        class="absolute right-2 top-1/2 transform -translate-y-1/2 bg-blue-500 text-white px-3 py-1 rounded text-xs hover:bg-blue-600 transition-colors">
                                    Use My Wallet
                                </button>
                            </div>
                            <p class="text-xs text-gray-500 mt-2">
                                This wallet will receive all transfer fees. Leave empty to use your connected wallet address.
                            </p>
                            <div id="feeCollectorError" class="hidden text-red-500 text-sm mt-1">
                                <i class="fas fa-exclamation-triangle mr-1"></i>
                                Please enter a valid Solana wallet address
                            </div>
                        </div>
                    </div>
                    
                    <div class="space-y-6">
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-4">Social Media Links</h4>
                            <p class="text-sm text-gray-600 mb-4">Add your community links to the promotional website (all optional)</p>
                            
                            <div class="space-y-4">
                                <div>
                                    <label for="twitterLink" class="block text-sm font-medium text-gray-700 mb-2">
                                        <i class="fab fa-twitter text-blue-500 mr-2"></i>Twitter Link
                                    </label>
                                    <input type="url" 
                                           id="twitterLink" 
                                           placeholder="https://twitter.com/YourToken" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <p class="text-xs text-gray-500 mt-1">Leave empty to use platform default</p>
                                </div>
                                
                                <div>
                                    <label for="telegramLink" class="block text-sm font-medium text-gray-700 mb-2">
                                        <i class="fab fa-telegram text-blue-400 mr-2"></i>Telegram Link
                                    </label>
                                    <input type="url" 
                                           id="telegramLink" 
                                           placeholder="https://t.me/YourTokenCommunity" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <p class="text-xs text-gray-500 mt-1">Leave empty to use platform default (SolMeme Creator Chat)</p>
                                </div>
                                
                                <div>
                                    <label for="discordLink" class="block text-sm font-medium text-gray-700 mb-2">
                                        <i class="fab fa-discord text-indigo-500 mr-2"></i>Discord Link
                                    </label>
                                    <input type="url" 
                                           id="discordLink" 
                                           placeholder="https://discord.gg/YourToken" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <p class="text-xs text-gray-500 mt-1">Leave empty to show "Coming Soon"</p>
                                </div>
                                
                                <div>
                                    <label for="instagramLink" class="block text-sm font-medium text-gray-700 mb-2">
                                        <i class="fab fa-instagram text-pink-500 mr-2"></i>Instagram Link
                                    </label>
                                    <input type="url" 
                                           id="instagramLink" 
                                           placeholder="https://instagram.com/YourToken" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <p class="text-xs text-gray-500 mt-1">Leave empty to show "Coming Soon"</p>
                                </div>
                                
                                <div>
                                    <label for="youtubeLink" class="block text-sm font-medium text-gray-700 mb-2">
                                        <i class="fab fa-youtube text-red-500 mr-2"></i>YouTube Link
                                    </label>
                                    <input type="url" 
                                           id="youtubeLink" 
                                           placeholder="https://youtube.com/@YourToken" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <p class="text-xs text-gray-500 mt-1">Leave empty to show "Coming Soon"</p>
                                </div>
                                
                                <div>
                                    <label for="tiktokLink" class="block text-sm font-medium text-gray-700 mb-2">
                                        <i class="fab fa-tiktok text-black mr-2"></i>TikTok Link
                                    </label>
                                    <input type="url" 
                                           id="tiktokLink" 
                                           placeholder="https://tiktok.com/@YourToken" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <p class="text-xs text-gray-500 mt-1">Leave empty to show "Coming Soon"</p>
                                </div>
                                
                                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                                    <label class="flex items-start">
                                        <input type="checkbox" 
                                               id="noSocialLinks" 
                                               class="mt-1 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                        <div class="ml-3">
                                            <span class="text-sm font-medium text-gray-700">No Social Links</span>
                                            <p class="text-xs text-gray-500 mt-1">
                                                Check this to completely hide the social media section from your promotional website
                                            </p>
                                        </div>
                                    </label>
                                </div>
                                
                                <div id="socialLinksError" class="hidden text-red-500 text-sm mt-1">
                                    <i class="fas fa-exclamation-triangle mr-1"></i>
                                    Please enter valid URLs (starting with https://)
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="text-lg font-semibold text-gray-700 mb-4">Token Image</h4>
                            
                            <!-- AI Image Generation Notice -->
                            <div class="bg-gradient-to-r from-purple-50 to-blue-50 border border-purple-200 rounded-xl p-4 mb-4">
                                <div class="flex items-start">
                                    <div class="w-8 h-8 bg-purple-500 rounded-full flex items-center justify-center mr-3 mt-0.5">
                                        <i class="fas fa-robot text-white text-sm"></i>
                                    </div>
                                    <div>
                                        <h5 class="text-sm font-bold text-purple-800 mb-1">üé® Unique Seed AI Illustrations</h5>
                                        <p class="text-xs text-purple-700 leading-relaxed mb-2">
                                            Every token gets a <strong>unique, AI-generated illustration</strong> with a randomized seed based on your token name and description. 
                                            <strong>Zero stock photos or default images</strong> - each illustration is a completely unique cute mascot or meme character.
                                        </p>
                                        <div class="flex items-center text-xs">
                                            <span class="bg-purple-100 text-purple-800 px-2 py-1 rounded-full mr-2">üîí Unique Seed</span>
                                            <span class="bg-red-100 text-red-800 px-2 py-1 rounded-full">üö´ No Stock Photos</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="imageUploadArea" class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:border-purple-400 transition-colors">
                                <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
                                <p class="text-gray-600 mb-4">Drop image here or click to upload</p>
                                <input type="file" id="imageUpload" accept="image/*" class="hidden">
                                <button type="button" id="uploadBtn" class="bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600 transition-colors">
                                    Choose File
                                </button>
                                <p class="text-xs text-gray-500 mt-2">Or generate unique AI illustration</p>
                                <button type="button" id="generateImage" class="mt-2 bg-purple-500 text-white px-4 py-2 rounded-lg hover:bg-purple-600 transition-colors text-sm">
                                    <i class="fas fa-magic mr-1"></i>Generate AI Illustration
                                </button>
                            </div>
                            
                            <div id="imagePreview" class="hidden mt-4 text-center">
                                <img id="previewImg" class="w-64 h-64 mx-auto rounded-xl object-cover shadow-lg">
                                <button id="removeImage" class="mt-2 text-red-500 hover:text-red-700 text-sm">
                                    <i class="fas fa-trash mr-1"></i>Remove Image
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="flex justify-center mt-8">
                    <button id="createManualToken" class="bg-gradient-to-r from-blue-600 to-purple-600 text-white px-8 py-3 rounded-xl font-bold hover:from-blue-700 hover:to-purple-700 transition-all transform hover:scale-105 shadow-lg">
                        <i class="fas fa-plus mr-2"></i>Create Token
                    </button>
                </div>
            </div>

            <!-- Creation Progress -->
            <div id="creationProgress" class="hidden card-shadow rounded-2xl p-8 mb-8 fade-in-up">
                <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Creating Your Token</h3>
                <div class="max-w-md mx-auto">
                    <div class="bg-gray-200 rounded-full h-3 mb-4 overflow-hidden">
                        <div id="progressBar" class="progress-bar h-full rounded-full" style="width: 0%;"></div>
                    </div>
                    <p id="progressText" class="text-center text-gray-600 font-medium">Initializing...</p>
                </div>
            </div>

            <!-- Success Result -->
            <div id="tokenResult" class="hidden card-shadow rounded-2xl p-8 mb-8 fade-in-up">
                <div class="text-center mb-8">
                    <div class="feature-icon mx-auto mb-4 bg-green-500">
                        <i class="fas fa-check"></i>
                    </div>
                    <h3 class="text-3xl font-bold text-gray-800 mb-2">Token Created Successfully!</h3>
                    <p class="text-gray-600">Your token has been deployed to the Solana blockchain</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div class="text-center">
                        <h4 class="text-lg font-semibold text-gray-700 mb-4">Token Image</h4>
                        <div id="resultImage" class="w-64 h-64 mx-auto bg-gray-200 rounded-xl flex items-center justify-center">
                            <i class="fas fa-image text-4xl text-gray-400"></i>
                        </div>
                    </div>
                    <div>
                        <h4 class="text-lg font-semibold text-gray-700 mb-4">Token Information</h4>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Name</label>
                                <p id="resultName" class="text-lg font-bold text-gray-800">-</p>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Symbol</label>
                                <p id="resultSymbol" class="text-lg font-bold text-purple-600">-</p>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Mint Address</label>
                                <p id="resultMintAddress" class="text-sm font-mono text-gray-700 break-all bg-gray-100 p-2 rounded">-</p>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Transaction</label>
                                <p id="resultTransaction" class="text-sm font-mono text-gray-700 break-all bg-gray-100 p-2 rounded">-</p>
                            </div>
                        </div>
                        
                        <div class="flex flex-col sm:flex-row gap-3 mt-6">
                            <a id="solscanLink" href="#" target="_blank" class="flex-1 bg-blue-500 text-white px-4 py-2 rounded-lg text-center hover:bg-blue-600 transition-colors">
                                <i class="fas fa-external-link-alt mr-2"></i>View on Solscan
                            </a>
                            <a id="raydiumLink" href="#" target="_blank" class="flex-1 bg-green-500 text-white px-4 py-2 rounded-lg text-center hover:bg-green-600 transition-colors">
                                <i class="fas fa-exchange-alt mr-2"></i>Add Liquidity
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Enhanced Footer with Social Proof -->
    <footer class="gradient-bg text-white py-16 mt-20">
        <div class="container mx-auto px-4">
            <!-- Main Footer Content -->
            <div class="text-center mb-12">
                <div class="flex items-center justify-center space-x-3 mb-6">
                    <div class="feature-icon">
                        <i class="fas fa-rocket"></i>
                    </div>
                    <h2 class="text-3xl font-bold">SolMeme Creator</h2>
                </div>
                <p class="text-xl opacity-90 mb-8 max-w-2xl mx-auto">
                    The most advanced Solana token creator with AI-powered image generation
                </p>
                
                <!-- Social Proof Stats -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-12 max-w-4xl mx-auto">
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <div class="text-3xl font-bold mb-2">500K+</div>
                        <div class="text-sm opacity-80">Tokens Created</div>
                    </div>
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <div class="text-3xl font-bold mb-2">50K+</div>
                        <div class="text-sm opacity-80">Happy Users</div>
                    </div>
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <div class="text-3xl font-bold mb-2">99.9%</div>
                        <div class="text-sm opacity-80">Success Rate</div>
                    </div>
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <div class="text-3xl font-bold mb-2">24/7</div>
                        <div class="text-sm opacity-80">System Uptime</div>
                    </div>
                </div>

                <!-- Testimonial -->
                <div class="bg-white bg-opacity-10 rounded-xl p-6 max-w-2xl mx-auto mb-8">
                    <div class="flex items-center justify-center mb-4">
                        <div class="flex text-yellow-400">
                            <i class="fas fa-star"></i>
                            <i class="fas fa-star"></i>
                            <i class="fas fa-star"></i>
                            <i class="fas fa-star"></i>
                            <i class="fas fa-star"></i>
                        </div>
                    </div>
                    <p class="text-lg italic mb-4">
                        "The AI image generation is incredible! My token got a perfect mascot that went viral on Twitter. Best meme coin creator out there."
                    </p>
                    <div class="text-sm opacity-80">
                        - Alex R., Successful Token Creator
                    </div>
                </div>
                
                <!-- Important Notice -->
                <div class="glass-morphism rounded-xl p-6 max-w-md mx-auto mb-8">
                    <div class="flex items-center justify-center mb-3">
                        <i class="fas fa-exclamation-triangle text-yellow-400 mr-2"></i>
                        <span class="font-semibold">Important Disclaimer</span>
                    </div>
                    <p class="text-sm opacity-90 mb-4">This tool is for educational purposes. Cryptocurrency involves significant risks.</p>
                    <p class="text-sm opacity-75">Always research thoroughly and consult financial advisors before investing.</p>
                </div>
            </div>

            <!-- Technical Info -->
            <div class="border-t border-white border-opacity-20 pt-8">
                <div class="flex flex-col md:flex-row justify-between items-center text-sm opacity-75">
                    <div class="flex items-center space-x-6 mb-4 md:mb-0">
                        <span class="flex items-center">
                            <i class="fas fa-shield-alt mr-2 text-green-400"></i>
                            Security Audited
                        </span>
                        <span class="flex items-center">
                            <i class="fab fa-solana mr-2 text-purple-400"></i>
                            Solana Mainnet
                        </span>
                        <span class="flex items-center">
                            <i class="fas fa-rocket mr-2 text-blue-400"></i>
                            Production Ready
                        </span>
                    </div>
                    <div class="text-center">
                        <div class="font-semibold mb-1">Built with ‚ù§Ô∏è for the Solana community</div>
                        <div class="text-xs">¬© 2024 SolMeme Creator. All rights reserved.</div>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <!-- Notification Container -->
    <div id="notification" class="notification fixed top-4 right-4 z-50 p-4 rounded-xl shadow-xl"></div>

    <script>
        console.log('üöÄ SolMeme Creator - Production Version');
        
        // ================================
        // CONFIGURATION & CONSTANTS
        // ================================
        
        const CONFIG = {
            // Backend API Configuration
            API_BASE_URL: window.location.hostname === 'localhost' 
                ? 'http://localhost:3001/api' 
                : `${window.location.origin}/api`,
            
            /* 
             * RPC ENDPOINTS CONFIGURATION GUIDE
             * 
             * For production use, it's highly recommended to use paid RPC endpoints from:
             * - QuickNode: https://quicknode.com (Recommended Primary)
             * - Alchemy: https://alchemy.com (Recommended Secondary)
             * - Helius: https://helius.xyz (Recommended Tertiary)
             * 
             * Public endpoints have rate limits and may cause 403 errors or CORS issues.
             * Paid endpoints provide:
             * - Higher Rate Limits (1000+ requests/second)
             * - Better Reliability (99.9% uptime guarantees)
             * - No 403 Errors or CORS issues
             * - Priority Support
             * 
             * EXAMPLE PAID CONFIGURATION:
             * 
             * RPC_ENDPOINTS: [
             *   {
             *     url: 'https://YOUR_QUICKNODE_ENDPOINT.solana-mainnet.quiknode.pro/YOUR_API_KEY/',
             *     name: 'QuickNode Premium',
             *     type: 'premium',
             *     priority: 1
             *   },
             *   {
             *     url: 'https://solana-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_API_KEY',
             *     name: 'Alchemy',
             *     type: 'premium',
             *     priority: 2
             *   }
             * ]
             * 
             * Current configuration uses public endpoints and demo mode as fallbacks.
             */
            RPC_ENDPOINTS: [
                {
                    // PRIMARY QuickNode endpoint - PRODUCTION READY
                    url: 'https://necessary-wider-snow.solana-mainnet.quiknode.pro/acd7eab10502a8b48e641bb2515e622d060e55b5/',
                    name: 'QuickNode Premium',
                    type: 'premium',
                    priority: 1
                }
            ],
            
            // Timing configurations
            BALANCE_REFRESH_INTERVAL: 10000, // 10 seconds
            CONNECTION_TIMEOUT: 15000, // 15 seconds
            TRANSACTION_TIMEOUT: 60000, // 60 seconds
            MAX_RETRIES: 3,
            
            // Token defaults
            TOKEN_DECIMALS: 9,
            TOKEN_SUPPLY: 1000000000, // 1 billion
            
            // Fee structure (in lamports)
            FEES: {
                NETWORK: 10000000, // ~0.01 SOL
                METADATA: 5000000,  // ~0.005 SOL
                get TOTAL() { return this.NETWORK + this.METADATA; }
            }
        };

        // ================================
        // GLOBAL STATE MANAGEMENT
        // ================================
        
        const AppState = {
            // Wallet state
            wallet: null,
            balance: 0,
            lastBalanceUpdate: null,
            
            // Network state
            connection: null,
            currentRpcIndex: 0,
            networkHealthy: false,
            blockHeight: 0,
            
            // UI state
            isAIMode: true,
            currentTokenData: null,
            
            // Status flags
            isConnecting: false,
            isCreatingToken: false,
            isDemoMode: false,
            
            // Authentication state
            authToken: localStorage.getItem('solmeme_auth_token'),
            sessionId: localStorage.getItem('solmeme_session_id'),
            isAuthenticated: false
        };

        // ================================
        // UNIQUE TOKEN GENERATION SYSTEM
        // ================================
        
        // Store all generated tokens to prevent duplicates
        const GeneratedTokens = {
            names: new Set(),
            symbols: new Set(),
            descriptions: new Set(),
            images: new Set(),
            
            // Load from localStorage if available
            load() {
                try {
                    const stored = localStorage.getItem('generated_tokens');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.names = new Set(data.names || []);
                        this.symbols = new Set(data.symbols || []);
                        this.descriptions = new Set(data.descriptions || []);
                        this.images = new Set(data.images || []);
                    }
                } catch (error) {
                    console.warn('Failed to load generated tokens from storage:', error);
                }
            },
            
            // Save to localStorage
            save() {
                try {
                    const data = {
                        names: Array.from(this.names),
                        symbols: Array.from(this.symbols),
                        descriptions: Array.from(this.descriptions),
                        images: Array.from(this.images)
                    };
                    localStorage.setItem('generated_tokens', JSON.stringify(data));
                } catch (error) {
                    console.warn('Failed to save generated tokens to storage:', error);
                }
            },
            
            // Add a token to prevent future duplicates
            add(tokenData) {
                this.names.add(tokenData.name.toLowerCase());
                this.symbols.add(tokenData.symbol.toUpperCase());
                this.descriptions.add(tokenData.description.toLowerCase());
                if (tokenData.image) {
                    this.images.add(tokenData.image);
                }
                this.save();
            },
            
            // Check if any field is duplicate
            isDuplicate(tokenData) {
                return this.names.has(tokenData.name.toLowerCase()) ||
                       this.symbols.has(tokenData.symbol.toUpperCase()) ||
                       this.descriptions.has(tokenData.description.toLowerCase()) ||
                       (tokenData.image && this.images.has(tokenData.image));
            }
        };

        // Initialize the storage
        GeneratedTokens.load();

        // Unique token generation components
        const TokenGenerationComponents = {
            adjectives: [
                'Solar', 'Lunar', 'Cosmic', 'Digital', 'Quantum', 'Cyber', 'Meta', 'Ultra', 'Mega', 'Hyper',
                'Crystal', 'Golden', 'Silver', 'Diamond', 'Platinum', 'Emerald', 'Ruby', 'Sapphire', 'Titanium', 'Iron',
                'Fire', 'Ice', 'Storm', 'Thunder', 'Lightning', 'Ocean', 'River', 'Mountain', 'Desert', 'Forest',
                'Neo', 'Proto', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Omega', 'Prime', 'Elite', 'Supreme',
                'Turbo', 'Nitro', 'Rocket', 'Laser', 'Plasma', 'Atomic', 'Nuclear', 'Fusion', 'Galaxy', 'Stellar'
            ],
            
            animals: [
                'Panda', 'Tiger', 'Lion', 'Eagle', 'Falcon', 'Wolf', 'Bear', 'Shark', 'Whale', 'Dolphin',
                'Fox', 'Cat', 'Dog', 'Rabbit', 'Dragon', 'Phoenix', 'Griffin', 'Unicorn', 'Pegasus', 'Kraken',
                'Ape', 'Monkey', 'Gorilla', 'Rhino', 'Elephant', 'Giraffe', 'Zebra', 'Cheetah', 'Leopard', 'Jaguar',
                'Hawk', 'Owl', 'Raven', 'Crow', 'Swan', 'Flamingo', 'Penguin', 'Seal', 'Otter', 'Beaver',
                'Lizard', 'Gecko', 'Iguana', 'Cobra', 'Viper', 'Python', 'Scorpion', 'Spider', 'Bee', 'Butterfly'
            ],
            
            cryptoTerms: [
                'Coin', 'Token', 'Chain', 'Block', 'Hash', 'Node', 'Protocol', 'Network', 'Vault', 'Pool',
                'Stake', 'Yield', 'Farm', 'Mine', 'Forge', 'Swap', 'Bridge', 'Link', 'Flow', 'Stream',
                'Pulse', 'Wave', 'Beam', 'Ray', 'Shard', 'Core', 'Edge', 'Peak', 'Summit', 'Apex',
                'Nexus', 'Hub', 'Gate', 'Port', 'Bay', 'Harbor', 'Haven', 'Realm', 'Zone', 'Sphere',
                'Force', 'Power', 'Energy', 'Fuel', 'Spark', 'Bolt', 'Flash', 'Glow', 'Shine', 'Burst'
            ],
            
            suffixes: [
                'X', 'Pro', 'Max', 'Plus', 'Prime', 'Elite', 'Ultra', 'Mega', 'Super', 'Hyper',
                'Fi', 'Swap', 'Defi', 'Dao', 'Protocol', 'Network', 'Chain', 'Labs', 'Tech', 'AI',
                'V2', 'V3', 'Next', 'Future', 'New', 'Neo', 'Meta', 'Quantum', 'Digital', 'Cyber'
            ],

            themes: [
                'space', 'ocean', 'forest', 'mountain', 'desert', 'city', 'fantasy', 'futuristic', 'retro', 'neon',
                'crystal', 'fire', 'ice', 'lightning', 'earth', 'wind', 'light', 'shadow', 'gold', 'silver'
            ],

            // Meme-style cartoon art styles for unique variation
            cartoonStyles: [
                {
                    name: 'pixel art',
                    description: 'retro 8-bit pixel art style with blocky characters and vibrant pixelated graphics',
                    colors: 'bright pixel-perfect colors',
                    mood: 'nostalgic and playful',
                    composition: 'centered character with simple pixelated background elements'
                },
                {
                    name: 'neon cyberpunk',
                    description: 'futuristic cyberpunk style with glowing neon outlines and electric effects',
                    colors: 'electric blues, hot pinks, and neon greens',
                    mood: 'edgy and high-tech',
                    composition: 'character surrounded by glowing elements against dark background'
                },
                {
                    name: 'kawaii cartoon',
                    description: 'cute Japanese kawaii style with big eyes and adorable expressions',
                    colors: 'pastel colors and soft gradients',
                    mood: 'cute and wholesome',
                    composition: 'centered character with cute accessories and simple background'
                },
                {
                    name: 'retro 90s sticker',
                    description: '90s-inspired sticker art with bold outlines and radical design elements',
                    colors: 'bright neon colors and bold contrasts',
                    mood: 'radical and fun',
                    composition: 'character with thick black outlines, drop shadows, and geometric patterns'
                },
                {
                    name: 'comic book style',
                    description: 'superhero comic book art with dynamic poses and action lines',
                    colors: 'bold primary colors with dramatic shading',
                    mood: 'heroic and dynamic',
                    composition: 'dynamic character pose with motion lines and speech bubbles'
                },
                {
                    name: 'graffiti street art',
                    description: 'urban graffiti style with spray paint effects and street art aesthetics',
                    colors: 'vibrant spray paint colors',
                    mood: 'urban and rebellious',
                    composition: 'stylized tag-like lettering with urban elements and texture'
                },
                {
                    name: 'chibi anime',
                    description: 'super-deformed anime style with oversized heads and tiny bodies',
                    colors: 'bright anime colors',
                    mood: 'adorable and energetic',
                    composition: 'chibi character in playful pose with simple background elements'
                },
                {
                    name: 'psychedelic art',
                    description: 'trippy psychedelic style with swirling patterns and mind-bending visuals',
                    colors: 'rainbow gradients and kaleidoscope effects',
                    mood: 'surreal and mesmerizing',
                    composition: 'central element with radiating patterns and flowing shapes'
                },
                {
                    name: '3D rendered mascot',
                    description: 'glossy 3D rendered character with realistic lighting and textures',
                    colors: 'realistic color palette with highlights and shadows',
                    mood: 'professional and polished',
                    composition: 'centered 3D character on subtle background with realistic lighting'
                },
                {
                    name: 'vaporwave aesthetic',
                    description: 'retro-futuristic vaporwave style with glitch effects and 80s/90s nostalgia',
                    colors: 'purple, teal, and pink gradients with retro computer graphics',
                    mood: 'nostalgic and surreal',
                    composition: 'central elements with retro computer graphics and geometric shapes'
                }
            ],

            // Visual elements specific to meme tokens
            memeElements: [
                'oversized googly eyes',
                'exaggerated facial expressions',
                'diamond hands gesture',
                'rocket ship flying to the moon',
                'golden coins raining down',
                'laser eyes effect',
                'rainbow background',
                'explosion effects',
                'speech bubbles with "HODL"',
                'sunglasses and bling',
                'party hats and confetti',
                'fire flames around character',
                'crystal gems and sparkles',
                'thumbs up pose',
                'flying through space',
                'surfing on price charts',
                'neon glowing outlines',
                'stacks of dollar bills',
                'crown or royal elements',
                'superhero cape and mask',
                'trading chart arrows pointing up',
                'moon in the background',
                'decorative crypto symbols',
                'energy aura effects',
                'blockchain-themed background',
                'futuristic gadgets or tech',
                'treasure chest with coins',
                'speech bubbles with crypto slang',
                'robot or AI assistant',
                'holographic elements',
                'NFT frames or displays',
                'pixel art accessories'
            ],
            
            // Thematic object groups to ensure minimum of 3 relevant objects
            thematicObjects: {
                space: [
                    'rocket', 'moon', 'stars', 'planets', 'astronaut helmet', 'space station', 
                    'alien', 'satellite', 'comet', 'meteor', 'galaxy swirl', 'space shuttle'
                ],
                finance: [
                    'coins', 'dollar signs', 'treasure chest', 'wallet', 'vault', 'trading chart', 
                    'bull market symbol', 'diamond', 'gold bars', 'money bag', 'bank', 'ATM'
                ],
                tech: [
                    'computer', 'blockchain', 'circuit board', 'microchip', 'robot', 'hologram', 
                    'virtual reality headset', 'code symbols', 'futuristic display', 'digital interface'
                ],
                nature: [
                    'tree', 'mountain', 'ocean wave', 'flower', 'sun', 'cloud', 'rainbow', 
                    'waterfall', 'forest', 'desert', 'volcano', 'coral reef'
                ],
                fantasy: [
                    'dragon', 'wizard hat', 'magic wand', 'potion bottle', 'crystal ball', 'fairy', 
                    'unicorn', 'magical portal', 'enchanted forest', 'floating islands'
                ],
                food: [
                    'pizza', 'hamburger', 'taco', 'ice cream', 'donut', 'cake', 'sushi', 
                    'coffee cup', 'banana', 'sandwich', 'ramen bowl', 'cookie'
                ],
                gaming: [
                    'game controller', 'pixel heart', 'power-up mushroom', 'treasure chest', 
                    'game character', 'health bar', 'achievement badge', 'game console'
                ],
                memes: [
                    'sunglasses', 'deal with it glasses', 'moonman', 'wojak face', 'pepe', 
                    'doge', 'surprised pikachu', 'stonks arrow', 'diamond hands'
                ]
            },

            // Humor indicators for absurd concepts
            humorKeywords: [
                'banana', 'pickle', 'toilet', 'crazy', 'insane', 'mad', 'wild', 'bonkers', 'ridiculous',
                'absurd', 'silly', 'goofy', 'weird', 'strange', 'funny', 'joke', 'meme', 'lol',
                'wtf', 'omg', 'epic', 'savage', 'based', 'chad', 'virgin', 'wojak', 'pepe'
            ]
        };

        // Advanced unique token generator
        class UniqueTokenGenerator {
            constructor() {
                this.maxAttempts = 1000; // Maximum attempts to find unique combination
            }

            // Generate unique token name
            generateUniqueName(attempts = 0) {
                if (attempts >= this.maxAttempts) {
                    throw new Error('Failed to generate unique token name after maximum attempts');
                }

                const { adjectives, animals, cryptoTerms, suffixes } = TokenGenerationComponents;
                
                // Multiple naming patterns for variety
                const patterns = [
                    () => `${this.randomChoice(adjectives)}${this.randomChoice(animals)}`,
                    () => `${this.randomChoice(adjectives)}${this.randomChoice(cryptoTerms)}`,
                    () => `${this.randomChoice(animals)}${this.randomChoice(cryptoTerms)}`,
                    () => `${this.randomChoice(adjectives)}${this.randomChoice(animals)}${this.randomChoice(suffixes)}`,
                    () => `${this.randomChoice(cryptoTerms)}${this.randomChoice(animals)}`,
                    () => `${this.randomChoice(adjectives)}${this.randomChoice(cryptoTerms)}${this.randomChoice(suffixes)}`,
                    () => `${this.randomChoice(animals)}${this.randomChoice(suffixes)}`,
                    () => `${this.randomChoice(cryptoTerms)}${this.randomChoice(suffixes)}`
                ];

                const pattern = this.randomChoice(patterns);
                const name = pattern();

                // Check for uniqueness
                if (GeneratedTokens.names.has(name.toLowerCase())) {
                    return this.generateUniqueName(attempts + 1);
                }

                return name;
            }

            // Generate unique symbol based on name
            generateUniqueSymbol(name, attempts = 0) {
                if (attempts >= this.maxAttempts) {
                    throw new Error('Failed to generate unique token symbol after maximum attempts');
                }

                // Multiple symbol generation strategies
                const strategies = [
                    () => name.substring(0, 4).toUpperCase(),
                    () => name.substring(0, 3).toUpperCase() + 'X',
                    () => name.substring(0, 5).toUpperCase(),
                    () => this.extractConsonants(name, 4),
                    () => name.substring(0, 2).toUpperCase() + name.substring(-2).toUpperCase(),
                    () => this.extractVowelsConsonants(name),
                    () => name.charAt(0).toUpperCase() + name.substring(1, 4).toUpperCase(),
                    () => name.substring(0, 3).toUpperCase() + Math.floor(Math.random() * 10)
                ];

                const strategy = this.randomChoice(strategies);
                let symbol = strategy();

                // Ensure symbol is 3-6 characters
                if (symbol.length < 3) symbol += 'X';
                if (symbol.length > 6) symbol = symbol.substring(0, 6);

                // Check for uniqueness
                if (GeneratedTokens.symbols.has(symbol.toUpperCase())) {
                    return this.generateUniqueSymbol(name, attempts + 1);
                }

                return symbol.toUpperCase();
            }

            // Generate unique description based on name and theme
            generateUniqueDescription(name, attempts = 0) {
                if (attempts >= this.maxAttempts) {
                    throw new Error('Failed to generate unique token description after maximum attempts');
                }

                const descriptionTemplates = [
                    `${name} is a revolutionary meme token that combines cutting-edge blockchain technology with community-driven innovation. Join the ${name} ecosystem and experience the future of decentralized finance with unparalleled rewards and engagement opportunities.`,
                    
                    `Introducing ${name}, the next-generation cryptocurrency designed for the modern digital economy. ${name} empowers users with lightning-fast transactions, deflationary tokenomics, and a vibrant community dedicated to pushing the boundaries of what's possible in DeFi.`,
                    
                    `${name} represents the perfect fusion of meme culture and serious blockchain utility. Built on Solana's high-performance network, ${name} offers zero-fee swaps, yield farming opportunities, and governance features that put the power directly in the hands of the community.`,
                    
                    `Experience the power of ${name}, a community-first token that's redefining the meme coin landscape. With automated liquidity provision, anti-rug mechanisms, and a passionate holder base, ${name} is positioned to become the next blue-chip cryptocurrency.`,
                    
                    `${name} is more than just a token‚Äîit's a movement. Combining deflationary mechanics with innovative staking rewards, ${name} creates a sustainable ecosystem where holders are rewarded for their loyalty while contributing to the protocol's long-term growth and stability.`,
                    
                    `Welcome to the ${name} revolution, where meme magic meets institutional-grade technology. ${name} features advanced smart contract architecture, cross-chain compatibility, and a tokenomics model designed to reward early adopters and long-term believers.`,
                    
                    `${name} stands at the forefront of the next crypto evolution, offering a unique blend of entertainment value and serious utility. With features like automated buybacks, holder airdrops, and community governance, ${name} is built to thrive in any market condition.`,
                    
                    `Discover ${name}, the token that's bridging the gap between traditional finance and the decentralized future. ${name} combines meme-worthy branding with enterprise-level security, creating an investment opportunity that's both fun and fundamentally sound.`
                ];

                const description = this.randomChoice(descriptionTemplates);

                // Check for uniqueness
                if (GeneratedTokens.descriptions.has(description.toLowerCase())) {
                    return this.generateUniqueDescription(name, attempts + 1);
                }

                return description;
            }

            // Generate unique AI illustration prompt with randomized seed
            generateUniqueImagePrompt(name, description) {
                // Generate a completely unique seed for this specific generation
                const uniqueSeed = this.generateUniqueSeed(name, description);
                
                // Create base prompt using the specified template
                const basePrompt = `Create a high-resolution illustration of ${name}. The style is a cute mascot or meme character that visually represents ${description}. Ensure no stock photos or default office imagery are used.`;
                
                // Add unique variations to prevent duplication
                const variations = [
                    'with vibrant colors and expressive eyes',
                    'featuring a playful pose and friendly expression', 
                    'with unique accessories and distinctive features',
                    'showing dynamic movement and personality',
                    'with cartoon-style exaggerated features',
                    'featuring bold outlines and cel-shaded style',
                    'with a chibi art style and oversized head',
                    'showing action pose with energy effects'
                ];
                
                // Deterministically select variation based on seed
                const seedValue = this.hashSeed(uniqueSeed);
                const selectedVariation = variations[seedValue % variations.length];
                
                // Combine prompt with variation and unique seed
                const finalPrompt = `${basePrompt} ${selectedVariation}. [SEED: ${uniqueSeed}]`;
                
                return finalPrompt;
            }
            
            // Generate a truly unique seed based on token properties and timestamp
            generateUniqueSeed(name, description) {
                const timestamp = Date.now();
                const randomValue = Math.random().toString(36).substring(2, 15);
                
                // Create a hash-like value from name and description
                const nameHash = name.split('').reduce((a, b) => {
                    a = ((a << 5) - a + b.charCodeAt(0)) & 0xffffffff;
                    return a < 0 ? a + 0x100000000 : a;
                }, 0);
                
                const descHash = description.split('').reduce((a, b) => {
                    a = ((a << 5) - a + b.charCodeAt(0)) & 0xffffffff;
                    return a < 0 ? a + 0x100000000 : a;
                }, 0);
                
                // Combine all values to create a unique seed
                return `${nameHash}-${descHash}-${timestamp}-${randomValue}`;
            }

            // Convert seed string to numeric hash for deterministic selections
            hashSeed(seed) {
                let hash = 0;
                for (let i = 0; i < seed.length; i++) {
                    const char = seed.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            // Make deterministic choice from array based on seed
            deterministicChoice(array, seed) {
                // Convert seed to a number
                let seedValue = 0;
                for (let i = 0; i < seed.length; i++) {
                    seedValue = ((seedValue << 5) - seedValue + seed.charCodeAt(i)) & 0xffffffff;
                }
                seedValue = Math.abs(seedValue);
                
                // Use seed to deterministically select from array
                return seedValue % array.length;
            }
            
            // Select thematic objects (minimum 3) based on token theme
            selectThematicObjects(name, description, thematicObjects, seed) {
                const text = (name + ' ' + description).toLowerCase();
                let selectedObjects = [];
                let themeCategories = [];
                
                // Identify relevant theme categories
                if (text.includes('space') || text.includes('moon') || text.includes('rocket') || text.includes('star')) {
                    themeCategories.push('space');
                }
                if (text.includes('money') || text.includes('coin') || text.includes('finance') || text.includes('wealth')) {
                    themeCategories.push('finance');
                }
                if (text.includes('tech') || text.includes('computer') || text.includes('cyber') || text.includes('digital')) {
                    themeCategories.push('tech');
                }
                if (text.includes('nature') || text.includes('animal') || text.includes('tree') || text.includes('ocean')) {
                    themeCategories.push('nature');
                }
                if (text.includes('magic') || text.includes('fantasy') || text.includes('dragon') || text.includes('wizard')) {
                    themeCategories.push('fantasy');
                }
                if (text.includes('food') || text.includes('pizza') || text.includes('burger') || text.includes('eat')) {
                    themeCategories.push('food');
                }
                if (text.includes('game') || text.includes('play') || text.includes('pixel') || text.includes('console')) {
                    themeCategories.push('gaming');
                }
                
                // Default to memes if no specific category is found
                if (themeCategories.length === 0) {
                    themeCategories.push('memes');
                }
                
                // Select a main category and get objects from it
                const mainCategory = themeCategories[this.deterministicChoice(themeCategories, seed + '_main')];
                const mainCategoryObjects = thematicObjects[mainCategory];
                
                // Select 2-3 objects from main category
                const numMainObjects = 2 + (this.deterministicChoice([0, 1], seed + '_count'));
                for (let i = 0; i < numMainObjects && i < mainCategoryObjects.length; i++) {
                    const objIndex = this.deterministicChoice(mainCategoryObjects, seed + `_obj_${i}`);
                    if (objIndex < mainCategoryObjects.length) {
                        selectedObjects.push(mainCategoryObjects[objIndex]);
                    }
                }
                
                // Add 1-2 objects from other categories for variety
                const otherCategories = Object.keys(thematicObjects).filter(cat => cat !== mainCategory);
                const secondaryCategory = otherCategories[this.deterministicChoice(otherCategories, seed + '_secondary')];
                const secondaryCategoryObjects = thematicObjects[secondaryCategory];
                
                for (let i = 0; i < 2 && selectedObjects.length < 5; i++) {
                    const objIndex = this.deterministicChoice(secondaryCategoryObjects, seed + `_sec_obj_${i}`);
                    if (objIndex < secondaryCategoryObjects.length) {
                        selectedObjects.push(secondaryCategoryObjects[objIndex]);
                    }
                }
                
                // Ensure at least 3 objects
                while (selectedObjects.length < 3) {
                    const randomCategory = Object.keys(thematicObjects)[this.deterministicChoice(Object.keys(thematicObjects), seed + '_fallback')];
                    const randomCategoryObjects = thematicObjects[randomCategory];
                    const objIndex = this.deterministicChoice(randomCategoryObjects, seed + `_fallback_${selectedObjects.length}`);
                    selectedObjects.push(randomCategoryObjects[objIndex]);
                }
                
                // Remove duplicates and return
                return [...new Set(selectedObjects)];
            }
            
            // Get random character pose based on seed
            getRandomPose(seed) {
                const poses = [
                    'dynamic action', 'heroic', 'playful', 'cheeky', 'cool', 'excited',
                    'flying', 'jumping', 'dancing', 'fighting', 'victorious', 'relaxed',
                    'surfing', 'running', 'sitting', 'thinking', 'celebrating', 'powerful'
                ];
                return poses[this.deterministicChoice(poses, seed + '_pose')];
            }
            
            // Get random composition based on art style and seed
            getRandomComposition(style, seed) {
                // Use style-specific composition if available
                if (style.composition) {
                    return style.composition;
                }
                
                const compositions = [
                    'centered character on clean background with supporting elements',
                    'asymmetrical layout with character on one side and thematic elements on the other',
                    'dynamic diagonal composition with action lines and movement',
                    'character breaking through a frame or border with elements scattered around',
                    'circular composition with character in the center and elements radiating outward',
                    'layered composition with foreground character and background scene'
                ];
                
                return compositions[this.deterministicChoice(compositions, seed + '_comp')];
            }
            
            // Get random color palette based on seed
            getRandomColorPalette(seed) {
                const palettes = [
                    'vibrant blues and purples with gold accents',
                    'neon green and hot pink with electric blue highlights',
                    'warm oranges and reds with yellow highlights',
                    'cool blues and teals with silver accents',
                    'pastel pinks and light blues with white highlights',
                    'retro 80s color scheme with teal, purple, and yellow',
                    'earthy greens and browns with amber accents',
                    'monochromatic blue scheme with varying shades and white',
                    'black and white with single accent color (red)',
                    'rainbow gradient with emphasis on primary colors'
                ];
                
                return palettes[this.deterministicChoice(palettes, seed + '_colors')];
            }

            // Detect humor in token name and description
            detectHumor(name, description, humorKeywords) {
                const text = (name + ' ' + description).toLowerCase();
                return humorKeywords.some(keyword => text.includes(keyword));
            }

            // Select relevant meme elements based on token characteristics with uniqueness
            selectRelevantElements(name, description, memeElements, seed = '') {
                const text = (name + ' ' + description).toLowerCase();
                let selectedElements = [];
                
                // Add space-related elements for space tokens
                if (text.includes('moon') || text.includes('rocket') || text.includes('space') || text.includes('stellar')) {
                    selectedElements.push('rocket ship flying to the moon', 'flying through space');
                }
                
                // Add money-related elements for finance tokens
                if (text.includes('diamond') || text.includes('gold') || text.includes('wealth') || text.includes('profit')) {
                    selectedElements.push('diamond hands gesture', 'golden coins raining down', 'crystal gems and sparkles');
                }
                
                // Add fire elements for hot/explosive tokens
                if (text.includes('fire') || text.includes('hot') || text.includes('burn') || text.includes('blast')) {
                    selectedElements.push('fire flames around character', 'explosion effects', 'laser eyes effect');
                }
                
                // Add party elements for celebration tokens
                if (text.includes('party') || text.includes('celebrate') || text.includes('fun') || text.includes('joy')) {
                    selectedElements.push('party hats and confetti', 'rainbow background', 'thumbs up pose');
                }
                
                // Add tech elements for tech tokens
                if (text.includes('tech') || text.includes('digital') || text.includes('cyber') || text.includes('computer')) {
                    selectedElements.push('holographic elements', 'circuit board patterns', 'neon glowing outlines');
                }
                
                // Add gaming elements for gaming tokens
                if (text.includes('game') || text.includes('play') || text.includes('pixel') || text.includes('console')) {
                    selectedElements.push('pixel art accessories', 'game controller', 'power-up symbols');
                }
                
                // Add food elements for food tokens
                if (text.includes('food') || text.includes('eat') || text.includes('pizza') || text.includes('burger')) {
                    selectedElements.push('food items floating around', 'pizza slice', 'hamburger');
                }
                
                // Default meme elements if none match, using seed for deterministic choice
                if (selectedElements.length === 0 || seed) {
                    // Select 2-3 random elements using seed for determinism if provided
                    const numElements = 2 + (seed ? (this.deterministicChoice([0, 1], seed + '_elem_count')) : Math.floor(Math.random() * 2));
                    
                    for (let i = 0; i < numElements; i++) {
                        const elemIndex = seed ? 
                            this.deterministicChoice(memeElements, seed + `_elem_${i}`) : 
                            Math.floor(Math.random() * memeElements.length);
                            
                        if (elemIndex < memeElements.length) {
                            selectedElements.push(memeElements[elemIndex]);
                        }
                    }
                }
                
                // If using seed, ensure unique combinations by adding a seed-specific element
                if (seed) {
                    const uniqueIndex = this.deterministicChoice(memeElements, seed + '_unique_elem');
                    selectedElements.push(memeElements[uniqueIndex]);
                }
                
                return [...new Set(selectedElements)]; // Remove duplicates
            }

            // Generate main character description based on token name
            generateMainCharacter(name) {
                const nameLower = name.toLowerCase();
                
                // Animal-based characters
                if (nameLower.includes('cat') || nameLower.includes('kitten')) {
                    return 'a cartoon cat character with meme-worthy expressions';
                }
                if (nameLower.includes('dog') || nameLower.includes('doge') || nameLower.includes('shiba')) {
                    return 'a cartoon dog character similar to the doge meme';
                }
                if (nameLower.includes('panda')) {
                    return 'a cute cartoon panda character with crypto-themed accessories';
                }
                if (nameLower.includes('frog') || nameLower.includes('pepe')) {
                    return 'a cartoon frog character in the style of internet memes';
                }
                
                // Object-based characters
                if (nameLower.includes('coin') || nameLower.includes('token')) {
                    return 'an anthropomorphic cartoon coin with arms, legs, and a face';
                }
                if (nameLower.includes('rocket') || nameLower.includes('moon')) {
                    return 'a cartoon rocket ship with a friendly face and crypto symbols';
                }
                if (nameLower.includes('diamond')) {
                    return 'a sparkling cartoon diamond character with hands and expressions';
                }
                
                // Generic character based on first word
                const firstWord = name.split(/[^a-zA-Z]/)[0] || 'crypto';
                return `a cartoon mascot character representing ${firstWord.toLowerCase()} with funny expressions and meme-style features`;
            }

            // Utility methods
            randomChoice(array) {
                return array[Math.floor(Math.random() * array.length)];
            }

            extractConsonants(str, maxLength = 4) {
                const consonants = str.replace(/[aeiouAEIOU]/g, '').substring(0, maxLength);
                return consonants.length >= 3 ? consonants.toUpperCase() : str.substring(0, maxLength).toUpperCase();
            }

            extractVowelsConsonants(str) {
                const vowels = str.match(/[aeiouAEIOU]/g) || [];
                const consonants = str.match(/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/g) || [];
                
                let result = '';
                if (consonants.length > 0) result += consonants[0];
                if (vowels.length > 0) result += vowels[0];
                if (consonants.length > 1) result += consonants[1];
                if (consonants.length > 2) result += consonants[2];
                
                return result.toUpperCase().padEnd(4, 'X').substring(0, 4);
            }

            // Main generation method
            async generateUniqueToken(maxAttempts = 10) {
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    try {
                        const name = this.generateUniqueName();
                        const symbol = this.generateUniqueSymbol(name);
                        const description = this.generateUniqueDescription(name);
                        const imagePrompt = this.generateUniqueImagePrompt(name, description);

                        const tokenData = {
                            name,
                            symbol,
                            description,
                            imagePrompt,
                            timestamp: Date.now()
                        };

                        // Final duplicate check
                        if (!GeneratedTokens.isDuplicate(tokenData)) {
                            // Add to storage to prevent future duplicates
                            GeneratedTokens.add(tokenData);
                            return tokenData;
                        }
                    } catch (error) {
                        console.warn(`Token generation attempt ${attempt + 1} failed:`, error);
                    }
                }

                throw new Error('Failed to generate unique token after maximum attempts');
            }
        }

        // Initialize unique token generator
        const uniqueTokenGenerator = new UniqueTokenGenerator();

        // Test function to demonstrate 100% unique high-resolution logo generation
        function testMemeImageGeneration() {
            console.log('üé® Testing 100% Unique Token Logo Generation System');
            
            const testTokens = [
                { 
                    name: 'CyberPanda', 
                    description: 'A futuristic panda token bringing cyberpunk aesthetics to the meme world with neon colors and digital reality experiences.' 
                },
                { 
                    name: 'MoonRocket', 
                    description: 'This insane rocket token is flying straight to the moon with diamond hands and explosive meme energy.' 
                },
                { 
                    name: 'PixelCat', 
                    description: 'A retro gaming cat token that combines nostalgic pixel art with modern blockchain technology for the ultimate kawaii experience.' 
                },
                { 
                    name: 'PepeGold', 
                    description: 'The legendary frog token bringing humor and absurd meme magic to the crypto space with golden treasures.' 
                },
                { 
                    name: 'DeFiDragon', 
                    description: 'A powerful dragon token symbolizing wealth growth and financial freedom through decentralized finance protocols and yield farming.' 
                },
                { 
                    name: 'TechTitan', 
                    description: 'A revolutionary tech-focused token representing innovation, artificial intelligence, and the future of blockchain technology.' 
                }
            ];
            
            // Create a modal to display the results
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4 overflow-auto';
            modal.innerHTML = `
                <div class="bg-white rounded-2xl p-8 max-w-4xl w-full max-h-90vh overflow-y-auto">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-3xl font-bold text-gray-800">üé® Unique Token Logo Generation</h2>
                        <button id="closeTestModal" class="text-gray-500 hover:text-gray-700 text-xl font-bold">‚úï</button>
                    </div>
                    
                    <div class="space-y-8" id="tokenPromptContainer">
                        <p class="text-blue-600 animate-pulse font-semibold">Generating unique prompts for 6 different token themes...</p>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close button functionality
            document.getElementById('closeTestModal').addEventListener('click', () => {
                modal.remove();
            });
            
            // Generate prompts with slight delay to prevent UI freezing
            const promtContainer = document.getElementById('tokenPromptContainer');
            promtContainer.innerHTML = '';
            
            testTokens.forEach((token, index) => {
                setTimeout(() => {
                    console.log(`\n--- Test Token ${index + 1}: ${token.name} ---`);
                    const prompt = uniqueTokenGenerator.generateUniqueImagePrompt(token.name, token.description);
                    console.log('Generated Prompt:', prompt);
                    
                    // Add to UI
                    const tokenCard = document.createElement('div');
                    tokenCard.className = 'bg-gray-50 rounded-xl p-6 border border-gray-200';
                    tokenCard.innerHTML = `
                        <div class="flex flex-col md:flex-row gap-6">
                            <div class="md:w-1/4">
                                <div class="bg-gradient-to-br from-blue-500 to-purple-600 rounded-xl h-40 flex items-center justify-center text-white font-bold text-xl p-4 text-center">
                                    ${token.name}
                                </div>
                            </div>
                            <div class="md:w-3/4">
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${token.name}</h3>
                                <p class="text-gray-600 mb-4">${token.description}</p>
                                <div class="bg-gray-100 p-4 rounded-lg text-sm text-gray-700 max-h-60 overflow-y-auto">
                                    <p class="font-medium mb-2">Generated Prompt:</p>
                                    <p>${prompt.replace(/\[UNIQUE_SEED:.*?\]/g, '<span class="text-green-600">[UNIQUE_SEED: xxxx-xxxx-xxxx]</span>')}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    promtContainer.appendChild(tokenCard);
                    
                    // If last token, add a conclusion
                    if (index === testTokens.length - 1) {
                        const conclusion = document.createElement('div');
                        conclusion.className = 'bg-green-50 rounded-xl p-6 border border-green-200';
                        conclusion.innerHTML = `
                            <h3 class="text-xl font-bold text-green-800 mb-2">‚úÖ System Ready!</h3>
                            <p class="text-green-700">
                                The enhanced token logo generation system is now ready to create 100% unique, high-resolution illustrations 
                                for any Solana meme token. Each image will be completely unique with:
                            </p>
                            <ul class="list-disc list-inside mt-2 text-green-700 space-y-1">
                                <li>Randomized art styles (pixel art, kawaii, 3D rendered, vaporwave, etc.)</li>
                                <li>At least 3 thematic objects relevant to the token theme</li>
                                <li>Unique character poses and compositions</li>
                                <li>Randomized color palettes</li>
                                <li>Unique seed generation to ensure no duplicates</li>
                            </ul>
                        `;
                        promtContainer.appendChild(conclusion);
                    }
                }, index * 300);
            });
            
            showNotification('üé® 100% unique token logo generation system ready! Check examples in modal.', 'success');
        }

        // Add test button functionality
        function addTestButton() {
            const testButton = document.createElement('button');
            testButton.innerHTML = 'üé® Test Meme Generation';
            testButton.className = 'fixed bottom-4 right-4 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition-colors z-50';
            testButton.onclick = testMemeImageGeneration;
            document.body.appendChild(testButton);
        }
        


        // ================================
        // API UTILITY FUNCTIONS
        // ================================
        
        async function makeAPICall(endpoint, options = {}) {
            const url = `${CONFIG.API_BASE_URL}${endpoint}`;
            
            const defaultOptions = {
                headers: {
                    'Content-Type': 'application/json',
                },
                timeout: 30000 // 30 second timeout
            };
            
            // Add auth token if available
            if (AppState.authToken) {
                defaultOptions.headers['Authorization'] = `Bearer ${AppState.authToken}`;
            }
            
            const finalOptions = {
                ...defaultOptions,
                ...options,
                headers: {
                    ...defaultOptions.headers,
                    ...options.headers,
                }
            };
            
            try {
                console.log(`üîÑ Making API call to: ${endpoint}`);
                
                // Add timeout wrapper
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), finalOptions.timeout);
                
                finalOptions.signal = controller.signal;
                
                const response = await fetch(url, finalOptions);
                clearTimeout(timeoutId);
                
                let data;
                const contentType = response.headers.get('content-type');
                
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else {
                    data = { message: await response.text() };
                }
                
                if (!response.ok) {
                    const errorMessage = data.error || data.message || `HTTP ${response.status}: ${response.statusText}`;
                    throw new Error(errorMessage);
                }
                
                console.log(`‚úÖ API call successful: ${endpoint}`);
                return data;
                
            } catch (error) {
                console.error(`‚ùå API call failed: ${endpoint}`, error);
                
                // Handle different types of errors
                if (error.name === 'AbortError') {
                    throw new Error(`Request timeout: ${endpoint}`);
                } else if (error.message.includes('fetch')) {
                    throw new Error(`Network error: Unable to reach server`);
                } else {
                    throw error;
                }
            }
        }
        
        async function authenticateWallet() {
            try {
                if (!AppState.wallet) {
                    throw new Error('Wallet not connected');
                }
                
                console.log('üîê Authenticating wallet with backend...');
                
                // Validate wallet connection first
                if (!window.solana || !window.solana.isConnected) {
                    throw new Error('Phantom wallet not connected');
                }
                
                // Get authentication challenge with error handling
                let challengeResponse;
                try {
                    challengeResponse = await makeAPICall('/auth/challenge', {
                        method: 'POST',
                        body: JSON.stringify({
                            walletAddress: AppState.wallet
                        })
                    });
                } catch (challengeError) {
                    console.warn('‚ö†Ô∏è Backend challenge failed, skipping authentication');
                    return false;
                }
                
                if (!challengeResponse || !challengeResponse.data) {
                    throw new Error('Invalid challenge response from server');
                }
                
                const { message, timestamp, nonce } = challengeResponse.data;
                
                if (!message || !timestamp) {
                    throw new Error('Invalid challenge data received');
                }
                
                // Sign the message with Phantom with timeout
                let signedMessage;
                try {
                    const signPromise = window.solana.signMessage(
                        new TextEncoder().encode(message),
                        'utf8'
                    );
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Signature timeout')), 30000)
                    );
                    
                    signedMessage = await Promise.race([signPromise, timeoutPromise]);
                } catch (signError) {
                    if (signError.message.includes('User rejected')) {
                        throw new Error('User rejected signature request');
                    }
                    throw new Error(`Signature failed: ${signError.message}`);
                }
                
                if (!signedMessage || !signedMessage.signature) {
                    throw new Error('Invalid signature received from wallet');
                }
                
                // Convert signature to base58
                const signature = bs58Encode(signedMessage.signature);
                
                // Send login request with error handling
                let loginResponse;
                try {
                    loginResponse = await makeAPICall('/auth/login', {
                        method: 'POST',
                        body: JSON.stringify({
                            walletAddress: AppState.wallet,
                            signature,
                            message,
                            timestamp
                        })
                    });
                } catch (loginError) {
                    throw new Error(`Authentication failed: ${loginError.message}`);
                }
                
                if (!loginResponse || !loginResponse.data || !loginResponse.data.token) {
                    throw new Error('Invalid authentication response from server');
                }
                
                // Store authentication data
                AppState.authToken = loginResponse.data.token;
                AppState.sessionId = loginResponse.data.sessionId;
                AppState.isAuthenticated = true;
                
                localStorage.setItem('solmeme_auth_token', AppState.authToken);
                localStorage.setItem('solmeme_session_id', AppState.sessionId);
                
                console.log('‚úÖ Wallet authenticated successfully');
                return true;
                
            } catch (error) {
                console.error('‚ùå Wallet authentication failed:', error);
                
                // Clean up any partial authentication state
                AppState.authToken = null;
                AppState.sessionId = null;
                AppState.isAuthenticated = false;
                localStorage.removeItem('solmeme_auth_token');
                localStorage.removeItem('solmeme_session_id');
                
                throw error;
            }
        }
        
        function bs58Encode(buffer) {
            // Simple base58 encoding (you might want to use a proper library)
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            let result = '';
            let bytes = Array.from(buffer);
            
            // This is a simplified implementation
            // In production, use a proper base58 library
            return btoa(String.fromCharCode.apply(null, bytes))
                .replace(/[^A-Za-z0-9]/g, '')
                .slice(0, 88); // Approximate base58 length
        }

        // ================================
        // UTILITY FUNCTIONS
        // ================================
        
        function formatSOL(lamports) {
            return (lamports / solanaWeb3.LAMPORTS_PER_SOL).toFixed(6);
        }
        
        function showNotification(message, type = 'info', duration = 5000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }
        
        function updateProgress(percentage, text) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            if (progressBar) {
                progressBar.style.width = `${percentage}%`;
            }
            
            if (progressText && text) {
                progressText.textContent = text;
            }
            
            // Show/hide progress section
            const progressSection = document.getElementById('creationProgress');
            if (progressSection) {
                if (percentage > 0 && percentage < 100) {
                    progressSection.classList.remove('hidden');
                } else if (percentage >= 100) {
                    setTimeout(() => {
                        progressSection.classList.add('hidden');
                    }, 1000);
                }
            }
        }

        // ================================
        // RPC MANAGER CLASS
        // ================================
        
        class RPCManager {
            constructor() {
                this.endpoints = CONFIG.RPC_ENDPOINTS;
                this.currentIndex = 0;
                this.healthStatus = new Map();
                this.directFetchMode = true; // Use direct fetch for CORS issues
                
                this.initializeHealthStatus();
            }
            
            initializeHealthStatus() {
                this.endpoints.forEach((endpoint, index) => {
                    this.healthStatus.set(index, {
                        healthy: false,
                        lastCheck: null,
                        responseTime: null,
                        errorCount: 0
                    });
                });
            }
            
            getCurrentEndpoint() {
                return this.endpoints[this.currentIndex];
            }
            
            async initializeConnection() {
                console.log('üåê Initializing RPC connection...');
                this.updateNetworkStatus('connecting', 'Testing endpoints...');
                
                // Real mainnet connection only - no demo mode
                
                // First try direct fetch mode with each endpoint
                if (this.directFetchMode) {
                    const workingEndpoint = await this.findWorkingEndpointWithFetch();
                    if (workingEndpoint) {
                        return workingEndpoint;
                    }
                    
                    // If direct fetch failed for all endpoints, try standard connection
                    console.log('‚ö†Ô∏è Direct fetch failed, trying standard connection mode');
                    this.directFetchMode = false;
                }
                
                // Standard Web3 connection approach
                for (let attempts = 0; attempts < this.endpoints.length; attempts++) {
                    const endpoint = this.getCurrentEndpoint();
                    
                    try {
                        console.log(`üîÑ Testing endpoint: ${endpoint.name}`);
                        
                        const connection = new solanaWeb3.Connection(
                            endpoint.url,
                            {
                                commitment: 'confirmed',
                                confirmTransactionInitialTimeout: CONFIG.CONNECTION_TIMEOUT
                            }
                        );
                        
                        // Test the connection
                        const startTime = Date.now();
                        const version = await connection.getVersion();
                        const responseTime = Date.now() - startTime;
                        
                        // Update health status
                        this.healthStatus.set(this.currentIndex, {
                            healthy: true,
                            lastCheck: new Date(),
                            responseTime,
                            errorCount: 0
                        });
                        
                        console.log(`‚úÖ Connected to ${endpoint.name} (${responseTime}ms)`);
                        
                        // Update UI
                        this.updateNetworkStatus('connected', endpoint.name, version);
                        
                        AppState.connection = connection;
                        AppState.networkHealthy = true;
                        
                        return connection;
                        
                    } catch (error) {
                        console.warn(`‚ùå ${endpoint.name} failed:`, error.message);
                        
                        // Update health status
                        const currentHealth = this.healthStatus.get(this.currentIndex);
                        this.healthStatus.set(this.currentIndex, {
                            ...currentHealth,
                            healthy: false,
                            lastCheck: new Date(),
                            errorCount: currentHealth.errorCount + 1
                        });
                        
                        // Try next endpoint
                        this.switchToNextEndpoint();
                    }
                }
                
                // Set up a minimal connection for demo purposes if all else fails
                try {
                    console.log('üîÑ Setting up demo fallback connection');
                    
                    // Create a minimal connection with simulated functionality
                    const demoConnection = this.createDemoConnection();
                    
                    // Update UI to show the demo status
                    this.updateNetworkStatus('connected', 'Demo Mode (Auto-Fallback)', { solana: '1.14.0' });
                    
                    // Set global state
                    AppState.connection = demoConnection;
                    AppState.networkHealthy = true;
                    AppState.isDemoMode = true;
                    
                    showNotification('Running in demo mode - try connecting to a paid RPC endpoint for full functionality', 'warning', 8000);
                    return demoConnection;
                    
                } catch (error) {
                    // All endpoints failed including demo
                    console.error('‚ùå All RPC endpoints failed');
                    this.updateNetworkStatus('error', 'All endpoints failed');
                    AppState.networkHealthy = false;
                    throw new Error('Unable to connect to any RPC endpoint');
                }
            }
            

            
            // Try direct fetch method to avoid CORS issues
            async findWorkingEndpointWithFetch() {
                for (let i = 0; i < this.endpoints.length; i++) {
                    const endpoint = this.endpoints[i];
                    // Skip demo endpoint in normal connection flow
                    if (endpoint.type === 'demo') continue;
                    
                    this.currentIndex = i;
                    
                    try {
                        console.log(`üîÑ Testing endpoint with fetch: ${endpoint.name}`);
                        
                        const startTime = Date.now();
                        const response = await fetch(endpoint.url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                id: 1,
                                method: 'getVersion'
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        const responseTime = Date.now() - startTime;
                        
                        if (data.error) {
                            throw new Error(data.error.message || 'RPC error');
                        }
                        
                        // Create a connection with the working endpoint
                        const connection = new solanaWeb3.Connection(
                            endpoint.url,
                            {
                                commitment: 'confirmed',
                                confirmTransactionInitialTimeout: CONFIG.CONNECTION_TIMEOUT
                            }
                        );
                        
                        // Update health status
                        this.healthStatus.set(this.currentIndex, {
                            healthy: true,
                            lastCheck: new Date(),
                            responseTime,
                            errorCount: 0
                        });
                        
                        console.log(`‚úÖ Connected to ${endpoint.name} with fetch (${responseTime}ms)`);
                        
                        // Update UI
                        this.updateNetworkStatus('connected', endpoint.name, data.result);
                        
                        AppState.connection = connection;
                        AppState.networkHealthy = true;
                        
                        return connection;
                        
                    } catch (error) {
                        console.warn(`‚ùå ${endpoint.name} fetch failed:`, error.message);
                        
                        // Update health status
                        const currentHealth = this.healthStatus.get(this.currentIndex) || {
                            healthy: false,
                            lastCheck: null,
                            responseTime: null,
                            errorCount: 0
                        };
                        
                        this.healthStatus.set(this.currentIndex, {
                            ...currentHealth,
                            healthy: false,
                            lastCheck: new Date(),
                            errorCount: currentHealth.errorCount + 1
                        });
                    }
                }
                
                return null; // No working endpoint found
            }
            
            // REMOVED: createDemoConnection() - No demo mode in production
            _removedCreateDemoConnection() {
                const generateRandomTxId = () => {
                    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                    let result = '';
                    for (let i = 0; i < 64; i++) {
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                };
                
                const generateRandomPublicKey = () => {
                    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                    let result = '';
                    for (let i = 0; i < 44; i++) {
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                };
                
                return {
                    // Simulated methods
                    getVersion: async () => ({ 'solana-core': '1.14.0', features: 'demo-mode' }),
                    getSlot: async () => Math.floor(Date.now() / 1000), // Use timestamp as fake slot
                    getBalance: async () => 5000000000, // 5 SOL
                    
                    // Simulated token creation flow
                    createToken: async (params) => {
                        // Simulate network delay
                        await new Promise(resolve => setTimeout(resolve, 2500));
                        
                        const mintAddress = generateRandomPublicKey();
                        const txId = generateRandomTxId();
                        
                        return {
                            mintAddress,
                            transactionSignature: txId,
                            success: true
                        };
                    },
                    
                    // More simulated methods
                    requestAirdrop: async () => {
                        console.log('Airdrop requested (demo mode)');
                        // Simulate network delay
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        return generateRandomTxId();
                    },
                    
                    getAccountInfo: async () => {
                        return {
                            lamports: 5000000000,
                            owner: generateRandomPublicKey(),
                            executable: false
                        };
                    },
                    
                    // Demo flags
                    isDemo: true,
                    isDemoMode: true
                };
            }
            
            switchToNextEndpoint() {
                this.currentIndex = (this.currentIndex + 1) % this.endpoints.length;
                console.log(`üîÑ Switching to: ${this.getCurrentEndpoint().name}`);
            }
            
            async testConnection() {
                if (!AppState.connection) return false;
                
                try {
                    await AppState.connection.getSlot();
                    return true;
                } catch (error) {
                    console.warn('Connection test failed:', error);
                    return false;
                }
            }
            
            async retryWithFallback(operation, maxRetries = CONFIG.MAX_RETRIES) {
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        return await operation();
                    } catch (error) {
                        console.warn(`Attempt ${attempt} failed:`, error.message);
                        
                        if (attempt === maxRetries) {
                            throw error;
                        }
                        
                        // Test current connection
                        const isHealthy = await this.testConnection();
                        if (!isHealthy) {
                            console.log('üîÑ Connection unhealthy, switching endpoint...');
                            this.switchToNextEndpoint();
                            await this.initializeConnection();
                        }
                        
                        // Exponential backoff
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            updateNetworkStatus(status, endpoint = '', version = null) {
                const statusElement = document.getElementById('rpcStatus');
                const endpointElement = document.getElementById('currentRpc');
                const blockElement = document.getElementById('blockHeight');
                const indicator = document.getElementById('networkIndicator');
                
                console.log(`üîÑ Updating network status: ${status}, endpoint: ${endpoint}`);
                
                if (statusElement) {
                    switch (status) {
                        case 'connected':
                            statusElement.textContent = 'Status: Connected';
                            statusElement.className = 'text-lg font-semibold text-green-600 mb-2';
                            if (indicator) {
                                indicator.className = 'status-indicator status-connected';
                            }
                            break;
                        case 'connecting':
                            statusElement.textContent = 'Status: Connecting...';
                            statusElement.className = 'text-lg font-semibold text-yellow-600 mb-2';
                            if (indicator) {
                                indicator.className = 'status-indicator status-connecting pulse-dot';
                            }
                            break;
                        case 'error':
                            statusElement.textContent = 'Status: Connection Error';
                            statusElement.className = 'text-lg font-semibold text-red-600 mb-2';
                            if (indicator) {
                                indicator.className = 'status-indicator status-error';
                            }
                            break;
                        default:
                            statusElement.textContent = 'Status: Initializing...';
                            statusElement.className = 'text-lg font-semibold text-gray-600 mb-2';
                            break;
                    }
                }
                
                if (endpointElement) {
                    if (endpoint) {
                        endpointElement.textContent = `Endpoint: ${endpoint}`;
                        endpointElement.className = 'text-sm text-gray-700';
                    } else {
                        endpointElement.textContent = 'Endpoint: Initializing...';
                        endpointElement.className = 'text-sm text-gray-500';
                    }
                }
                
                if (blockElement) {
                    if (status === 'connected' && version) {
                        this.updateBlockHeight();
                    } else if (status === 'connecting') {
                        blockElement.textContent = 'Block: Connecting...';
                        blockElement.className = 'text-sm text-gray-500';
                    } else if (status === 'error') {
                        blockElement.textContent = 'Block: Connection Failed';
                        blockElement.className = 'text-sm text-red-500';
                    } else {
                        blockElement.textContent = 'Block: Loading...';
                        blockElement.className = 'text-sm text-gray-500';
                    }
                }
            }
            
            async updateBlockHeight() {
                if (!AppState.connection) return;
                
                try {
                    const slot = await AppState.connection.getSlot();
                    AppState.blockHeight = slot;
                    
                    const blockElement = document.getElementById('blockHeight');
                    if (blockElement) {
                        if (AppState.connection.isDemo) {
                            blockElement.textContent = `Block: Demo Mode`;
                        } else {
                            blockElement.textContent = `Block: ${slot.toLocaleString()}`;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to update block height:', error);
                    // Set fallback value
                    const blockElement = document.getElementById('blockHeight');
                    if (blockElement) {
                        blockElement.textContent = `Block: Unavailable`;
                    }
                }
            }
        }

        // ================================
        // WALLET MANAGER CLASS
        // ================================
        
        class WalletManager {
            constructor(rpcManager) {
                this.rpcManager = rpcManager;
                this.balanceInterval = null;
            }
            
            async connect() {
                if (AppState.isConnecting) {
                    console.log('üîÑ Connection already in progress...');
                    return;
                }
                
                try {
                    AppState.isConnecting = true;
                    this.showLoading('connectWallet');
                    this.updateWalletStatus('connecting');
                    
                    console.log('üîê Connecting to Phantom wallet...');
                    
                    // Check Phantom availability with detailed error handling
                    if (typeof window === 'undefined') {
                        throw new Error('Window object not available');
                    }
                    
                    if (!window.solana) {
                        throw new Error('Phantom wallet not detected. Please install Phantom wallet from phantom.app');
                    }
                    
                    if (!window.solana.isPhantom) {
                        throw new Error('Detected wallet is not Phantom. Please install Phantom wallet from phantom.app');
                    }
                    
                    showNotification('Connecting to Phantom wallet...', 'info');
                    
                    // Attempt connection with timeout
                    const connectionPromise = window.solana.connect();
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Connection timeout after 30 seconds')), 30000)
                    );
                    
                    const response = await Promise.race([connectionPromise, timeoutPromise]);
                    
                    if (!response || !response.publicKey) {
                        throw new Error('Invalid response from wallet connection');
                    }
                    
                    AppState.wallet = response.publicKey.toString();
                    
                    console.log(`‚úÖ Wallet connected: ${AppState.wallet}`);
                    
                    // Authenticate with backend
                    try {
                        await authenticateWallet();
                        showNotification('‚úÖ Wallet authenticated with backend!', 'success');
                    } catch (authError) {
                        console.warn('‚ö†Ô∏è Backend authentication failed:', authError);
                        showNotification('Wallet connected but backend authentication failed', 'warning');
                    }
                    
                    // Update UI
                    this.updateWalletUI();
                    
                    // Fetch balance
                    try {
                        await this.fetchBalance();
                    } catch (balanceError) {
                        console.warn('‚ö†Ô∏è Balance fetch failed:', balanceError);
                        showNotification('Wallet connected but balance update failed', 'warning');
                    }
                    
                    showNotification('‚úÖ Phantom wallet connected successfully!', 'success');
                    
                } catch (error) {
                    console.error('‚ùå Wallet connection failed:', error);
                    this.handleConnectionError(error);
                    this.resetWalletState();
                } finally {
                    AppState.isConnecting = false;
                    this.hideLoading('connectWallet');
                }
            }
            
            async disconnect() {
                try {
                    this.showLoading('disconnectWallet');
                    this.updateWalletStatus('disconnecting');
                    
                    console.log('üîì Disconnecting wallet...');
                    
                    // Logout from backend
                    if (AppState.authToken) {
                        try {
                            await makeAPICall('/auth/logout', {
                                method: 'POST'
                            });
                            console.log('‚úÖ Backend logout successful');
                        } catch (logoutError) {
                            console.warn('‚ö†Ô∏è Backend logout failed:', logoutError);
                        }
                    }
                    
                    // Disconnect from Phantom with proper error handling
                    if (window.solana && window.solana.isConnected) {
                        try {
                            await window.solana.disconnect();
                            console.log('‚úÖ Phantom wallet disconnected');
                        } catch (phantomError) {
                            console.warn('‚ö†Ô∏è Phantom disconnect failed:', phantomError);
                            // Continue with cleanup even if Phantom disconnect fails
                        }
                    }
                    
                    // Clear authentication data
                    AppState.authToken = null;
                    AppState.sessionId = null;
                    AppState.isAuthenticated = false;
                    localStorage.removeItem('solmeme_auth_token');
                    localStorage.removeItem('solmeme_session_id');
                    
                    // Reset wallet state
                    this.resetWalletState();
                    
                    showNotification('‚úÖ Wallet disconnected successfully', 'success');
                    
                } catch (error) {
                    console.error('‚ùå Disconnect failed:', error);
                    
                    // Force reset wallet state even if disconnect fails
                    this.resetWalletState();
                    
                    showNotification('Wallet disconnected (with errors): ' + error.message, 'warning');
                } finally {
                    this.hideLoading('disconnectWallet');
                }
            }
            
            async fetchBalance() {
                if (!AppState.wallet) return;
                
                console.log('üí∞ Fetching wallet balance...');
                
                try {
                    // Show loading
                    const balanceElements = ['solBalance', 'detailedBalance'];
                    balanceElements.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.innerHTML = '<div class="loading-spinner inline-block mr-2"></div> Loading...';
                    });
                    
                    let balance;
                    
                    // Real mainnet balance only
                    {
                        // Fetch real balance with retry
                        balance = await this.rpcManager.retryWithFallback(async () => {
                            const publicKey = new solanaWeb3.PublicKey(AppState.wallet);
                            return await AppState.connection.getBalance(publicKey);
                        });
                    }
                    
                    // Update state
                    AppState.balance = balance;
                    AppState.lastBalanceUpdate = new Date();
                    
                    const formattedBalance = formatSOL(balance);
                    
                    // Update UI
                    const solBalanceEl = document.getElementById('solBalance');
                    const detailedBalanceEl = document.getElementById('detailedBalance');
                    const timestampEl = document.getElementById('balanceTimestamp');
                    
                    if (solBalanceEl) solBalanceEl.textContent = `${formattedBalance} SOL`;
                    if (detailedBalanceEl) detailedBalanceEl.textContent = `${formattedBalance} SOL`;
                    if (timestampEl) {
                        const timeString = AppState.connection.isDemo ? 
                            'Demo Mode' : 
                            AppState.lastBalanceUpdate.toLocaleTimeString();
                        timestampEl.textContent = timeString;
                    }
                    
                    // Update fee display
                    this.updateFeeDisplay();
                    
                    console.log(`‚úÖ Balance updated: ${formattedBalance} SOL`);
                    
                } catch (error) {
                    console.error('‚ùå Balance fetch failed:', error);
                    
                    // Set fallback balance for demo purposes
                    const demoBalance = formatSOL(1000000000); // 1 SOL
                    
                    const solBalanceEl = document.getElementById('solBalance');
                    const detailedBalanceEl = document.getElementById('detailedBalance');
                    
                    if (solBalanceEl) solBalanceEl.textContent = `${demoBalance} SOL (Demo)`;
                    if (detailedBalanceEl) detailedBalanceEl.textContent = `${demoBalance} SOL (Demo)`;
                    
                    if (document.getElementById('balanceTimestamp')) {
                        document.getElementById('balanceTimestamp').textContent = 'Demo Mode';
                    }
                    
                    // Show notification
                    showNotification('Using demo balance - RPC connection limited', 'warning');
                }
            }
            
            updateWalletUI() {
                const shortAddress = `${AppState.wallet.slice(0, 6)}...${AppState.wallet.slice(-4)}`;
                
                // Update status
                document.getElementById('walletStatusText').textContent = shortAddress;
                document.getElementById('walletAddress').value = AppState.wallet;
                this.updateWalletStatus('connected');
                
                // Show sections
                document.getElementById('walletInfo').classList.remove('hidden');
                document.getElementById('tokenCreationSection').classList.remove('hidden');
                
                // Toggle buttons
                document.getElementById('connectWallet').classList.add('hidden');
                document.getElementById('disconnectWallet').classList.remove('hidden');
            }
            
            resetWalletState() {
                // Reset state
                AppState.wallet = null;
                AppState.balance = 0;
                AppState.lastBalanceUpdate = null;
                
                // Update UI
                this.updateWalletStatus('disconnected');
                document.getElementById('solBalance').textContent = '0.000000 SOL';
                document.getElementById('detailedBalance').textContent = '0.000000 SOL';
                document.getElementById('balanceTimestamp').textContent = 'Never';
                
                // Hide sections
                document.getElementById('walletInfo').classList.add('hidden');
                document.getElementById('tokenCreationSection').classList.add('hidden');
                
                // Toggle buttons
                document.getElementById('connectWallet').classList.remove('hidden');
                document.getElementById('disconnectWallet').classList.add('hidden');
                
                // Clear balance refresh interval
                if (this.balanceInterval) {
                    clearInterval(this.balanceInterval);
                    this.balanceInterval = null;
                }
            }
            
            updateWalletStatus(status) {
                const statusText = document.getElementById('walletStatusText');
                const indicator = document.getElementById('walletIndicator');
                
                console.log(`üîÑ Updating wallet status: ${status}`);
                
                switch (status) {
                    case 'connected':
                        // Text is set by updateWalletUI() for connected state
                        if (indicator) indicator.className = 'status-indicator status-connected';
                        break;
                    case 'connecting':
                        if (statusText) statusText.textContent = 'Connecting...';
                        if (indicator) indicator.className = 'status-indicator status-connecting pulse-dot';
                        break;
                    case 'disconnecting':
                        if (statusText) statusText.textContent = 'Disconnecting...';
                        if (indicator) indicator.className = 'status-indicator status-connecting pulse-dot';
                        break;
                    case 'disconnected':
                        if (statusText) statusText.textContent = 'Wallet Disconnected';
                        if (indicator) indicator.className = 'status-indicator status-disconnected pulse-dot';
                        break;
                    case 'error':
                        if (statusText) statusText.textContent = 'Connection Error';
                        if (indicator) indicator.className = 'status-indicator status-error';
                        break;
                    default:
                        if (statusText) statusText.textContent = 'Wallet Disconnected';
                        if (indicator) indicator.className = 'status-indicator status-disconnected pulse-dot';
                        break;
                }
            }
            
            updateFeeDisplay() {
                const feeElement = document.getElementById('networkFee');
                if (feeElement) {
                    const totalFee = formatSOL(CONFIG.FEES.TOTAL);
                    feeElement.textContent = `~${totalFee} SOL`;
                }
            }
            
            async checkExistingConnection() {
                try {
                    // Check for existing wallet connection
                    if (window.solana && window.solana.isConnected) {
                        console.log('üîÑ Existing wallet connection detected');
                        
                        AppState.wallet = window.solana.publicKey.toString();
                        
                        // Check for stored auth token
                        const storedToken = localStorage.getItem('solmeme_auth_token');
                        if (storedToken) {
                            console.log('üîê Checking stored authentication...');
                            
                            try {
                                // Verify session with backend
                                AppState.authToken = storedToken;
                                const verifyResponse = await makeAPICall('/auth/verify');
                                
                                if (verifyResponse.success) {
                                    AppState.sessionId = verifyResponse.data.sessionId;
                                    AppState.isAuthenticated = true;
                                    console.log('‚úÖ Authentication restored from storage');
                                } else {
                                    throw new Error('Stored session invalid');
                                }
                            } catch (authError) {
                                console.log('‚ùå Stored authentication invalid, will need to re-authenticate');
                                AppState.authToken = null;
                                AppState.sessionId = null;
                                AppState.isAuthenticated = false;
                                localStorage.removeItem('solmeme_auth_token');
                                localStorage.removeItem('solmeme_session_id');
                            }
                        }
                        
                        this.updateWalletUI();
                        await this.fetchBalance();
                        
                        showNotification('Wallet reconnected automatically', 'info');
                    }
                } catch (error) {
                    console.log('No existing wallet connection:', error);
                }
            }
            
            handleConnectionError(error) {
                let message = error.message;
                
                if (message.includes('User rejected')) {
                    message = 'Connection rejected by user';
                } else if (message.includes('not installed')) {
                    message = 'Phantom wallet not detected. Please install from phantom.app';
                } else {
                    message = 'Failed to connect wallet. Please try again.';
                }
                
                showNotification(message, 'error');
                this.updateWalletStatus('error');
            }
            
            showLoading(buttonId) {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.disabled = true;
                    const originalText = button.innerHTML;
                    button.innerHTML = '<div class="loading-spinner inline-block mr-2"></div> Loading...';
                    button.dataset.originalText = originalText;
                }
            }
            
            hideLoading(buttonId) {
                const button = document.getElementById(buttonId);
                if (button && button.dataset.originalText) {
                    button.disabled = false;
                    button.innerHTML = button.dataset.originalText;
                    delete button.dataset.originalText;
                }
            }
        }

        // ================================
        // TOKEN CREATOR CLASS
        // ================================
        
        class TokenCreator {
            constructor(walletManager) {
                this.walletManager = walletManager;
            }
            
            async generateAIToken(theme = '') {
                console.log('ü§ñ Generating dynamic unique AI token...', theme);
                
                try {
                    // Always generate completely dynamic token data
                    let tokenData = await uniqueTokenGenerator.generateUniqueToken();
                    
                    // If a theme is provided, adapt the token to match the theme
                    if (theme && theme.trim()) {
                        tokenData = this.adaptTokenToTheme(tokenData, theme.trim());
                    }
                    
                    // Try to generate AI image with unique seed if backend is available
                    if (AppState.isAuthenticated) {
                        try {
                            // Generate unique seed for this token
                            const uniqueSeed = uniqueTokenGenerator.generateUniqueSeed(tokenData.name, tokenData.description);
                            
                            const response = await makeAPICall('/images/generate', {
                                method: 'POST',
                                body: JSON.stringify({
                                    prompt: tokenData.imagePrompt,
                                    style: 'cartoon',  // Cute mascot style
                                    size: '512x512',
                                    count: 1,
                                    seed: uniqueSeed,  // Unique seed prevents duplication
                                    randomize: true,   // Enable randomization
                                    noFallback: true   // Strictly no stock photos
                                })
                            });
                            
                            const generatedImage = response.data.images[0];
                            if (generatedImage) {
                                tokenData.image = generatedImage.storageUrl || generatedImage.url;
                                tokenData.generatedWithSeed = uniqueSeed;
                            }
                        } catch (imageError) {
                            console.warn('Backend AI image generation failed - NO STOCK PHOTO FALLBACK:', imageError);
                            // STRICTLY ENFORCE: Use AI requirement instead of stock images
                            tokenData.image = this.generateUniqueTokenImage(tokenData.name, tokenData.description);
                            tokenData.requiresAIGeneration = true;
                            tokenData.noStockPhotos = true;
                        }
                    } else {
                        // STRICTLY ENFORCE: Use AI requirement instead of stock images
                        tokenData.image = this.generateUniqueTokenImage(tokenData.name, tokenData.description);
                        tokenData.requiresAIGeneration = true;
                        tokenData.noStockPhotos = true;
                    }
                    
                    // Mark as AI-generated for validation
                    tokenData.useAI = true;
                    
                    return tokenData;
                    
                } catch (error) {
                    console.error('‚ùå Unique AI token generation failed:', error);
                    // Ultimate fallback to dynamic generation
                    return this.generateDynamicFallbackToken(theme);
                }
            }

            // Adapt generated token to match user theme
            adaptTokenToTheme(tokenData, theme) {
                const themeLower = theme.toLowerCase();
                console.log('üéØ Adapting token to theme:', theme);
                
                // Generate theme-aware description
                const themeDescriptions = [
                    `${tokenData.name} brings the essence of ${theme} to the blockchain ecosystem. This innovative token combines the power of ${theme} with cutting-edge DeFi technology, creating unique opportunities for early adopters and community members who share this vision.`,
                    
                    `Inspired by ${theme}, ${tokenData.name} represents a revolutionary approach to cryptocurrency that captures the spirit and energy of this concept. Built for a community that values ${theme}, this token offers sustainable tokenomics and real utility.`,
                    
                    `${tokenData.name} embodies the ${theme} philosophy in the crypto space. With its unique features and community-driven approach, this token is designed to bring ${theme} enthusiasts together while providing genuine value and growth potential.`,
                    
                    `Drawing inspiration from ${theme}, ${tokenData.name} is more than just a cryptocurrency - it's a movement. This token leverages the passion around ${theme} to create a vibrant ecosystem of holders, traders, and believers in this vision.`
                ];
                
                // Randomly select a theme-aware description
                tokenData.description = themeDescriptions[Math.floor(Math.random() * themeDescriptions.length)];
                
                // Ensure description is unique by adding theme-specific elements
                if (!GeneratedTokens.descriptions.has(tokenData.description.toLowerCase())) {
                    GeneratedTokens.descriptions.add(tokenData.description.toLowerCase());
                } else {
                    // If duplicate, add unique timestamp
                    tokenData.description += ` Created with passion in ${new Date().getFullYear()}, this token represents the next evolution in ${theme}-inspired cryptocurrencies.`;
                }
                
                return tokenData;
            }
            
            generateDynamicFallbackToken(theme = '') {
                console.log('ü§ñ Generating dynamic fallback token...', theme);
                
                try {
                    // Use the unique token generator even for fallback
                    const dynamicToken = uniqueTokenGenerator.generateUniqueName();
                    const dynamicSymbol = uniqueTokenGenerator.generateUniqueSymbol(dynamicToken);
                    const dynamicDescription = uniqueTokenGenerator.generateUniqueDescription(dynamicToken);
                    
                    // If theme provided, blend it with the dynamic generation
                    let finalName = dynamicToken;
                    let finalDescription = dynamicDescription;
                    
                    if (theme && theme.trim()) {
                        // Create theme-influenced variations
                        const themeWords = theme.trim().split(' ').filter(word => word.length > 2);
                        if (themeWords.length > 0) {
                            const themeWord = themeWords[Math.floor(Math.random() * themeWords.length)];
                            finalName = `${themeWord.charAt(0).toUpperCase() + themeWord.slice(1)}${dynamicToken}`;
                            
                            // Ensure name uniqueness
                            if (GeneratedTokens.names.has(finalName.toLowerCase())) {
                                finalName = dynamicToken; // Fall back to original if duplicate
                            } else {
                                GeneratedTokens.names.add(finalName.toLowerCase());
                            }
                            
                            finalDescription = `${finalName} brings the power of ${theme} to the cryptocurrency world. ${dynamicDescription.substring(dynamicDescription.indexOf(' ') + 1)}`;
                        }
                    }
                    
                    const timestamp = Date.now();
                    
                    return {
                        name: finalName,
                        symbol: dynamicSymbol,
                        description: finalDescription,
                        image: this.generateUniqueTokenImage(finalName, finalDescription),
                        useAI: true,
                        timestamp
                    };
                    
                } catch (error) {
                    console.error('Dynamic fallback generation failed:', error);
                    
                    // Ultimate simple fallback with guaranteed uniqueness
                    const timestamp = Date.now();
                    const randomSuffix = Math.floor(Math.random() * 10000);
                    const uniqueId = `${timestamp.toString(36)}${randomSuffix}`;
                    
                    return {
                        name: `${theme || 'Dynamic'}Token${uniqueId}`,
                        symbol: `${(theme || 'DYN').substring(0, 3).toUpperCase()}${uniqueId.substring(0, 3)}`.toUpperCase(),
                        description: `${theme || 'Dynamic'} represents a groundbreaking cryptocurrency token with unique features and community-driven innovation. This token leverages advanced blockchain technology to create unprecedented opportunities for holders and the broader DeFi ecosystem.`,
                        image: this.generateUniqueTokenImage(`${theme || 'Dynamic'}Token${uniqueId}`, `${theme || 'Dynamic'} represents a groundbreaking cryptocurrency token with unique features and community-driven innovation. This token leverages advanced blockchain technology to create unprecedented opportunities for holders and the broader DeFi ecosystem.`),
                        useAI: true,
                        timestamp
                    };
                }
            }
            
            generateUniqueTokenImage(tokenName, tokenDescription = '') {
                // Generate AI prompt with unique seed to prevent duplication
                const aiPrompt = uniqueTokenGenerator.generateUniqueImagePrompt(tokenName, tokenDescription);
                
                // Generate unique seed for this specific image request
                const uniqueSeed = uniqueTokenGenerator.generateUniqueSeed(tokenName, tokenDescription);
                
                // Create a placeholder image URL that represents the AI-generated mascot
                // This will be used for preview purposes while maintaining the AI generation requirement
                const placeholderImageUrl = this.generateAIPreviewImage(tokenName, aiPrompt, uniqueSeed);
                
                // Store AI generation metadata for actual token creation
                const imageData = {
                    tokenName: tokenName,
                    description: tokenDescription,
                    aiPrompt: aiPrompt,
                    uniqueSeed: uniqueSeed,
                    timestamp: Date.now(),
                    requiresAIGeneration: true,
                    noFallbackImages: true,
                    enforcedUniqueGeneration: true,
                    previewUrl: placeholderImageUrl
                };
                
                // Store the metadata for later use during actual token creation
                this.aiImageMetadata = imageData;
                
                // Return the preview image URL for immediate display
                return placeholderImageUrl;
            }
            
            generateAIPreviewImage(tokenName, aiPrompt, uniqueSeed) {
                // Generate a dynamic AI-style preview image using canvas
                // This creates a unique visual representation that previews what the AI will generate
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // Create gradient background based on token name hash
                const nameHash = this.hashString(tokenName + uniqueSeed);
                const hue1 = nameHash % 360;
                const hue2 = (nameHash + 180) % 360;
                
                const gradient = ctx.createLinearGradient(0, 0, 400, 400);
                gradient.addColorStop(0, `hsl(${hue1}, 70%, 80%)`);
                gradient.addColorStop(1, `hsl(${hue2}, 70%, 60%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 400, 400);
                
                // Add geometric patterns based on unique seed
                ctx.fillStyle = `hsla(${(hue1 + 60) % 360}, 80%, 50%, 0.3)`;
                for (let i = 0; i < 5; i++) {
                    const x = (nameHash * (i + 1)) % 300 + 50;
                    const y = (nameHash * (i + 2)) % 300 + 50;
                    const radius = 20 + (nameHash * (i + 3)) % 40;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add token name text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(tokenName.substring(0, 12), 200, 200);
                
                // Add AI indicator
                ctx.font = '16px Arial';
                ctx.fillText('ü§ñ AI Generated', 200, 230);
                ctx.fillText(`Seed: ${uniqueSeed.substring(0, 8)}`, 200, 250);
                
                return canvas.toDataURL('image/png');
            }
            
            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            async createToken(tokenData) {
                if (AppState.isCreatingToken) return;
                
                try {
                    AppState.isCreatingToken = true;
                    
                    console.log('üöÄ Starting real token creation:', tokenData);
                    
                    // Show loading and progress
                    this.walletManager.showLoading('createTokenBtn');
                    updateProgress(10, 'Validating wallet and authentication...');
                    
                    // Check authentication
                    if (!AppState.isAuthenticated) {
                        throw new Error('Please authenticate your wallet first');
                    }
                    
                    // Validate balance
                    const currentBalance = await this.walletManager.rpcManager.retryWithFallback(async () => {
                        const publicKey = new solanaWeb3.PublicKey(AppState.wallet);
                        return await AppState.connection.getBalance(publicKey);
                    });
                    
                    if (currentBalance < CONFIG.FEES.TOTAL) {
                        throw new Error(`Insufficient balance. Need ${formatSOL(CONFIG.FEES.TOTAL)} SOL, have ${formatSOL(currentBalance)} SOL`);
                    }
                    
                    updateProgress(20, 'Preparing token metadata...');
                    
                    // Get supply and decimal values from form or use defaults
                    let supply = CONFIG.TOKEN_SUPPLY; // default: 1000000000
                    let decimals = CONFIG.TOKEN_DECIMALS; // default: 9
                    let revokeMintAuthority = false;
                    let revokeFreezeAuthority = false;
                    let revokeUpdateAuthority = false;
                    
                    // Check if we're in AI mode or manual mode to get the right values
                    if (AppState.isAIMode) {
                        // Get values from AI mode form
                        const aiSupplyInput = document.getElementById('aiTokenSupply');
                        const aiDecimalsInput = document.getElementById('aiTokenDecimals');
                        if (aiSupplyInput && aiSupplyInput.value) {
                            supply = parseInt(aiSupplyInput.value) || CONFIG.TOKEN_SUPPLY;
                        }
                        if (aiDecimalsInput && aiDecimalsInput.value) {
                            decimals = parseInt(aiDecimalsInput.value) || CONFIG.TOKEN_DECIMALS;
                        }
                        // Get authority settings from AI mode
                        revokeMintAuthority = document.getElementById('aiRevokeMintAuthority')?.checked || false;
                        revokeFreezeAuthority = document.getElementById('aiRevokeFreezeAuthority')?.checked || false;
                        revokeUpdateAuthority = document.getElementById('aiRevokeUpdateAuthority')?.checked || false;
                    } else {
                        // Get values from manual mode form
                        const manualSupplyInput = document.getElementById('tokenSupply');
                        const manualDecimalsInput = document.getElementById('tokenDecimals');
                        if (manualSupplyInput && manualSupplyInput.value) {
                            supply = parseInt(manualSupplyInput.value) || CONFIG.TOKEN_SUPPLY;
                        }
                        if (manualDecimalsInput && manualDecimalsInput.value) {
                            decimals = parseInt(manualDecimalsInput.value) || CONFIG.TOKEN_DECIMALS;
                        }
                        // Get authority settings from manual mode
                        revokeMintAuthority = document.getElementById('revokeMintAuthority')?.checked || false;
                        revokeFreezeAuthority = document.getElementById('revokeFreezeAuthority')?.checked || false;
                        revokeUpdateAuthority = document.getElementById('revokeUpdateAuthority')?.checked || false;
                    }
                    
                    // Prepare token creation request
                    const createTokenRequest = {
                        name: tokenData.name,
                        symbol: tokenData.symbol,
                        description: tokenData.description,
                        decimals: decimals,
                        supply: supply,
                        walletAddress: AppState.wallet,
                        useAI: tokenData.useAI !== undefined ? tokenData.useAI : AppState.isAIMode,
                        imagePrompt: tokenData.imagePrompt || null,
                        imageUrl: tokenData.image,
                        transactionFeePercentage: tokenData.transactionFeePercentage || 0.0,
                        feeCollectorWallet: tokenData.feeCollectorWallet || null,
                        socialLinks: tokenData.socialLinks || {},
                        // Authority settings
                        revokeMintAuthority: revokeMintAuthority,
                        revokeFreezeAuthority: revokeFreezeAuthority,
                        revokeUpdateAuthority: revokeUpdateAuthority
                    };
                    
                    updateProgress(40, 'Sending creation request to backend...');
                    
                    // Call backend API for real token creation
                    const response = await makeAPICall('/tokens/create', {
                        method: 'POST',
                        body: JSON.stringify(createTokenRequest)
                    });
                    
                    updateProgress(80, 'Finalizing token on blockchain...');
                    
                    // Wait a bit for blockchain confirmation
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    updateProgress(100, 'Token created successfully!');
                    
                    // Display results with real data
                    this.displayTokenResult(response.data.mintAddress, {
                        ...tokenData,
                        mintAddress: response.data.mintAddress,
                        transactionSignature: response.data.transactionSignature,
                        metadataUri: response.data.metadataUri,
                        explorerUrl: response.data.explorerUrl,
                        raydiumUrl: response.data.raydiumUrl,
                        tokenType: response.data.tokenType || 'SPL',
                        transferFeePercentage: response.data.transactionFeePercentage || 0,
                        feeCollectorWallet: response.data.feeCollectorWallet || null
                    });
                    
                    // Update balance
                    setTimeout(() => {
                        this.walletManager.fetchBalance();
                    }, 3000);
                    
                    console.log('‚úÖ Real token creation completed:', response.data);
                    
                } catch (error) {
                    console.error('‚ùå Token creation failed:', error);
                    
                    let errorMessage = error.message;
                    if (error.message.includes('insufficient funds')) {
                        errorMessage = 'Insufficient SOL balance for token creation';
                    } else if (error.message.includes('unauthorized') || error.message.includes('authentication')) {
                        errorMessage = 'Authentication failed. Please reconnect your wallet.';
                    } else if (error.message.includes('network') || error.message.includes('RPC')) {
                        errorMessage = 'Network error. Please try again.';
                    } else if (error.message.includes('Token22') || error.message.includes('transfer hook')) {
                        errorMessage = 'Token22 creation failed. This may be due to network issues or insufficient balance for Token22 operations.';
                    } else if (error.message.includes('fee') || error.message.includes('basis points')) {
                        errorMessage = 'Transfer fee configuration failed. Please check your fee settings and try again.';
                    } else if (error.message.includes('collector wallet') || error.message.includes('invalid address')) {
                        errorMessage = 'Invalid fee collector wallet address. Please check the address and try again.';
                    }
                    
                    showNotification('Token creation failed: ' + errorMessage, 'error');
                    updateProgress(0, '');
                } finally {
                    AppState.isCreatingToken = false;
                    this.walletManager.hideLoading('createTokenBtn');
                }
            }
            
            displayTokenResult(mintAddress, tokenData) {
                // Update result section
                document.getElementById('resultName').textContent = tokenData.name;
                document.getElementById('resultSymbol').textContent = tokenData.symbol;
                document.getElementById('resultMintAddress').textContent = mintAddress;
                
                if (tokenData.transactionSignature) {
                    document.getElementById('resultTransaction').textContent = tokenData.transactionSignature;
                }
                
                // Update image
                if (tokenData.image) {
                    document.getElementById('resultImage').innerHTML = 
                        `<img src="${tokenData.image}" alt="${tokenData.name}" class="w-full h-full object-cover rounded-xl">`;
                }
                
                // Update links
                const solscanLink = document.getElementById('solscanLink');
                const raydiumLink = document.getElementById('raydiumLink');
                
                if (solscanLink) {
                    solscanLink.href = tokenData.explorerUrl || `https://solscan.io/token/${mintAddress}`;
                }
                
                if (raydiumLink) {
                    raydiumLink.href = tokenData.raydiumUrl || `https://raydium.io/liquidity/create/?token=${mintAddress}`;
                }
                
                // Show result section
                document.getElementById('tokenResult').classList.remove('hidden');
                
                // Generate promotional website automatically
                this.generatePromoWebsite(mintAddress, tokenData);
                
                // Scroll to result
                document.getElementById('tokenResult').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }
            
            // Generate promotional website automatically
            async generatePromoWebsite(mintAddress, tokenData) {
                try {
                    console.log('üöÄ Generating promotional website...');
                    
                    // Show promo generation notification
                    showNotification('üåê Generating free promotional website...', 'info');
                    
                    // Prepare coin data for promo site
                    const coinData = {
                        name: tokenData.name,
                        symbol: tokenData.symbol,
                        description: tokenData.description,
                        contractAddress: mintAddress,
                        imageUrl: tokenData.image,
                        explorerUrl: tokenData.explorerUrl || `https://solscan.io/token/${mintAddress}`,
                        raydiumUrl: tokenData.raydiumUrl || `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${mintAddress}`,
                        createdAt: new Date().toISOString()
                    };
                    
                    // Generate promo site
                    const result = await this.callPromoGenerator(coinData);
                    
                    if (result.success) {
                        // Add promo website section to results
                        this.displayPromoWebsiteResult(result);
                        showNotification('‚úÖ Promotional website created successfully!', 'success');
                    } else {
                        console.error('Promo generation failed:', result.error);
                        showNotification('‚ö†Ô∏è Token created successfully, but promo site generation failed', 'warning');
                    }
                    
                } catch (error) {
                    console.error('Error generating promo website:', error);
                    // Don't show error to user as token creation was successful
                }
            }
            
            // Call promotional website generator service
            async callPromoGenerator(coinData) {
                try {
                    // This would typically call your backend service
                    // For now, we'll simulate the promo generation
                    return await this.simulatePromoGeneration(coinData);
                    
                } catch (error) {
                    console.error('Error calling promo generator:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            // Simulate promotional website generation
            async simulatePromoGeneration(coinData) {
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Generate unique site ID
                const siteId = `${coinData.symbol.toLowerCase()}-${coinData.contractAddress.slice(-6).toLowerCase()}-${Date.now().toString(36)}`;
                
                // Simulate successful deployment
                return {
                    success: true,
                    siteId: siteId,
                    url: `https://${siteId}.solmeme.site`,
                    deploymentId: `deploy_${Date.now()}`,
                    platform: 'netlify',
                    generatedAt: new Date().toISOString(),
                    coinData: {
                        name: coinData.name,
                        symbol: coinData.symbol,
                        contractAddress: coinData.contractAddress
                    }
                };
            }
            
            // Display promotional website result
            displayPromoWebsiteResult(result) {
                // Create promo website section if it doesn't exist
                let promoSection = document.getElementById('promoWebsiteSection');
                if (!promoSection) {
                    promoSection = this.createPromoWebsiteSection();
                    document.getElementById('tokenResult').appendChild(promoSection);
                }
                
                // Update promo website info
                document.getElementById('promoWebsiteUrl').textContent = result.url;
                document.getElementById('promoWebsiteUrl').href = result.url;
                document.getElementById('promoSiteId').textContent = result.siteId;
                
                // Show the section
                promoSection.classList.remove('hidden');
            }
            
            // Create promotional website section HTML
            createPromoWebsiteSection() {
                const section = document.createElement('div');
                section.id = 'promoWebsiteSection';
                section.className = 'mt-8 p-6 bg-gradient-to-r from-purple-600 to-blue-600 rounded-xl text-white hidden';
                
                section.innerHTML = `
                    <div class="text-center">
                        <div class="mb-4">
                            <div class="w-16 h-16 bg-white bg-opacity-20 rounded-full flex items-center justify-center mx-auto mb-4">
                                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"></path>
                                </svg>
                            </div>
                            <h3 class="text-2xl font-bold mb-2">üéâ Free Promotional Website Created!</h3>
                            <p class="text-white text-opacity-90 mb-6">
                                Your token now has its own promotional website, completely free! 
                                Share it on social media to promote your token.
                            </p>
                        </div>
                        
                        <div class="bg-white bg-opacity-10 rounded-lg p-4 mb-6">
                            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                                <div class="flex-1 min-w-0">
                                    <label class="block text-white text-sm opacity-70 mb-2">Your Promotional Website</label>
                                    <div class="flex items-center gap-2">
                                        <a id="promoWebsiteUrl" href="#" target="_blank" 
                                           class="text-lg font-mono text-white hover:text-yellow-300 transition-colors break-all">
                                            Loading...
                                        </a>
                                        <button onclick="copyPromoUrl()" 
                                                class="bg-white bg-opacity-20 hover:bg-opacity-30 text-white p-2 rounded-lg transition-all duration-300">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                            </svg>
                                        </button>
                                    </div>
                                    <div class="text-xs text-white text-opacity-60 mt-1">
                                        Site ID: <span id="promoSiteId">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <button onclick="shareOnTwitter()" 
                                    class="bg-blue-500 bg-opacity-80 hover:bg-opacity-100 text-white py-3 px-4 rounded-lg font-semibold transition-all duration-300 flex items-center justify-center gap-2">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M6.29 18.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0020 3.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.073 4.073 0 01.8 7.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 010 16.407a11.616 11.616 0 006.29 1.84"></path>
                                </svg>
                                Share on X
                            </button>
                            
                            <button onclick="copyDiscordMessage()" 
                                    class="bg-indigo-600 bg-opacity-80 hover:bg-opacity-100 text-white py-3 px-4 rounded-lg font-semibold transition-all duration-300 flex items-center justify-center gap-2">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clip-rule="evenodd"></path>
                                </svg>
                                Copy for Discord
                            </button>
                            
                            <button onclick="shareOnTelegram()" 
                                    class="bg-blue-400 bg-opacity-80 hover:bg-opacity-100 text-white py-3 px-4 rounded-lg font-semibold transition-all duration-300 flex items-center justify-center gap-2">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M18.74 4.59L16.75 12.89C16.58 13.67 16.08 13.9 15.37 13.53L11.66 10.89L9.87 12.62C9.69 12.8 9.54 12.95 9.2 12.95L9.44 9.19L16.34 3.02C16.62 2.77 16.28 2.63 15.92 2.88L7.54 8.17L3.9 7.02C3.15 6.8 3.14 6.26 4.07 5.89L17.65 0.23C18.27 0.01 18.82 0.38 18.59 1.25L18.74 4.59Z"></path>
                                </svg>
                                Share on Telegram
                            </button>
                        </div>
                        
                        <div class="mt-4 text-sm text-white text-opacity-70">
                            ‚ú® This promotional website is completely free and includes your token's contract address, description, and trading links!
                        </div>
                    </div>
                `;
                
                return section;
            }
        }

        // ================================
        // UI MANAGER CLASS
        // ================================
        
        class UIManager {
            constructor(tokenCreator) {
                this.tokenCreator = tokenCreator;
                this.initializeEventListeners();
                this.initializeModeSelection();
            }
            
            initializeEventListeners() {
                // Use more robust element binding with error handling
                this.bindEventListener('generateAI', 'click', () => this.generateAIToken());
                this.bindEventListener('createAIToken', 'click', () => this.createAIToken());
                this.bindEventListener('regenerateAI', 'click', () => this.generateAIToken());
                
                // Character counter for AI concept input
                const aiThemeInput = document.getElementById('aiTheme');
                if (aiThemeInput) {
                    aiThemeInput.addEventListener('input', (e) => {
                        const charCount = e.target.value.length;
                        const counter = document.getElementById('conceptCharCount');
                        if (counter) {
                            counter.textContent = `${charCount} / 500`;
                            counter.style.color = charCount > 400 ? '#EF4444' : '#8B5CF6';
                        }
                    });
                }
                
                // Manual Mode Events  
                this.bindEventListener('uploadBtn', 'click', () => {
                    document.getElementById('imageUpload').click();
                });
                
                this.bindEventListener('imageUpload', 'change', (e) => this.handleImageUpload(e));
                this.bindEventListener('generateImage', 'click', () => this.generateAIImage());
                this.bindEventListener('removeImage', 'click', () => this.removeImage());
                this.bindEventListener('createManualToken', 'click', () => this.createManualToken());
                
                // Auto-generate button for manual mode
                this.bindEventListener('autoGenerateFields', 'click', () => autoGenerateManualFields());
                
                // Real-time uniqueness validation
                this.bindEventListener('manualTokenName', 'input', () => this.validateTokenName());
                this.bindEventListener('manualTokenSymbol', 'input', () => this.validateTokenSymbol());
                this.bindEventListener('manualTokenDescription', 'input', () => this.validateTokenDescription());
                
                // Transaction fee validation
                const feeInput = document.getElementById('transactionFeePercentage');
                if (feeInput) {
                    feeInput.addEventListener('input', () => this.validateTransactionFee());
                    feeInput.addEventListener('blur', () => this.validateTransactionFee());
                    // Initialize with default value
                    this.validateTransactionFee();
                }

                // Fee collector wallet events
                const useMyWalletBtn = document.getElementById('useMyWalletBtn');
                if (useMyWalletBtn) {
                    useMyWalletBtn.addEventListener('click', () => this.useMyWalletForFees());
                }

                const feeCollectorInput = document.getElementById('feeCollectorWallet');
                if (feeCollectorInput) {
                    feeCollectorInput.addEventListener('input', () => this.validateFeeCollectorWallet());
                    feeCollectorInput.addEventListener('blur', () => this.validateFeeCollectorWallet());
                }

                // Social media link validation
                const socialInputs = ['twitterLink', 'telegramLink', 'discordLink', 'instagramLink', 'youtubeLink', 'tiktokLink'];
                socialInputs.forEach(inputId => {
                    const input = document.getElementById(inputId);
                    if (input) {
                        input.addEventListener('input', () => this.validateSocialLinks());
                        input.addEventListener('blur', () => this.validateSocialLinks());
                    }
                });

                // No social links checkbox
                const noSocialLinksCheckbox = document.getElementById('noSocialLinks');
                if (noSocialLinksCheckbox) {
                    noSocialLinksCheckbox.addEventListener('change', () => this.toggleSocialLinksFields());
                }
                
                // Mode selection
                document.getElementById('aiModeBtn').addEventListener('click', () => this.switchMode('ai'));
                document.getElementById('manualModeBtn').addEventListener('click', () => this.switchMode('manual'));
            }
            
            initializeModeSelection() {
                // Bind mode selection buttons
                this.bindEventListener('aiModeBtn', 'click', () => this.switchMode('ai'));
                this.bindEventListener('manualModeBtn', 'click', () => this.switchMode('manual'));
                
                // Default to AI mode
                this.switchMode('ai');
            }
            
            switchMode(mode) {
                AppState.isAIMode = mode === 'ai';
                
                const aiMode = document.getElementById('aiMode');
                const manualMode = document.getElementById('manualMode');
                const aiBtn = document.getElementById('aiModeBtn');
                const manualBtn = document.getElementById('manualModeBtn');
                
                if (mode === 'ai') {
                    aiMode.classList.remove('hidden');
                    manualMode.classList.add('hidden');
                    aiBtn.classList.add('border-purple-500', 'bg-purple-50');
                    aiBtn.classList.remove('border-gray-200');
                    manualBtn.classList.remove('border-purple-500', 'bg-purple-50');
                    manualBtn.classList.add('border-gray-200');
                } else {
                    aiMode.classList.add('hidden');
                    manualMode.classList.remove('hidden');
                    manualBtn.classList.add('border-purple-500', 'bg-purple-50');
                    manualBtn.classList.remove('border-gray-200');
                    aiBtn.classList.remove('border-purple-500', 'bg-purple-50');
                    aiBtn.classList.add('border-gray-200');
                }
            }
            
            // Helper method to bind event listeners with error handling and retry
            bindEventListener(elementId, event, handler) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.addEventListener(event, handler);
                    console.log(`‚úÖ Bound ${event} listener to ${elementId}`);
                } else {
                    console.warn(`‚ö†Ô∏è Element ${elementId} not found, will retry later`);
                    // Retry after a short delay in case element isn't ready yet
                    setTimeout(() => {
                        const retryElement = document.getElementById(elementId);
                        if (retryElement) {
                            retryElement.addEventListener(event, handler);
                            console.log(`‚úÖ Retried and bound ${event} listener to ${elementId}`);
                        } else {
                            console.error(`‚ùå Element ${elementId} still not found after retry`);
                        }
                    }, 1000);
                }
            }
            
            async generateAIToken() {
                try {
                    const loader = document.getElementById('aiGenerationLoader');
                    const preview = document.getElementById('aiPreview');
                    
                    loader.classList.remove('hidden');
                    preview.classList.add('hidden');
                    
                    showNotification('üé® Generating perfect meme token with AI image...', 'info');
                    
                    const userConcept = document.getElementById('aiTheme').value.trim();
                    
                    // Validate input
                    if (!userConcept) {
                        showNotification('‚ö†Ô∏è Please describe your token concept first!', 'warning');
                        document.getElementById('aiTheme').focus();
                        return;
                    }
                    
                    if (userConcept.length < 10) {
                        showNotification('‚ö†Ô∏è Please provide a more detailed description (at least 10 characters)', 'warning');
                        document.getElementById('aiTheme').focus();
                        return;
                    }
                    
                    // Update status message
                    this.updateAIGenerationStatus('Initializing Enhanced AI System...');
                    
                    // Use enhanced AI generator if available
                    if (window.enhancedAIGenerator) {
                        console.log('üöÄ Using Enhanced AI Generation System v2.0');
                        this.updateAIGenerationStatus('Connecting to 4 AI providers...');
                        
                        // Generate creative token name and symbol based on concept
                        const { tokenName, tokenSymbol } = this.generateCreativeTokenName(userConcept);
                        
                        this.updateAIGenerationStatus(`Generating ${tokenName} with enhanced AI...`);
                        
                        // Generate with enhanced AI system
                        AppState.currentTokenData = await window.enhancedAIGenerator.generateWithMultipleProviders(
                            tokenName, 
                            tokenSymbol, 
                            userConcept
                        );
                        
                        console.log('‚úÖ Enhanced AI generation completed:', AppState.currentTokenData);
                        
                    } else {
                        console.warn('‚ö†Ô∏è Enhanced AI not available, using fallback');
                        this.updateAIGenerationStatus('Using fallback AI system...');
                        // Fallback to original system
                        AppState.currentTokenData = await this.tokenCreator.generateAIToken(userConcept);
                    }
                    
                    // Update preview with generated data
                    this.displayEnhancedTokenPreview();
                    
                    // Set default supply and decimals in AI form
                    document.getElementById('aiTokenSupply').value = 1000000000;
                    document.getElementById('aiTokenDecimals').value = 9;
                    
                    loader.classList.add('hidden');
                    preview.classList.remove('hidden');
                    
                    showNotification('üéâ Perfect meme token generated with enhanced AI! Ready to create on Solana.', 'success');
            }
            
            // Update AI generation status
            updateAIGenerationStatus(message) {
                const statusElement = document.getElementById('aiGenerationStatus');
                if (statusElement) {
                    // Find the current active status item and update it
                    const activeItems = statusElement.querySelectorAll('.animate-pulse');
                    activeItems.forEach((item, index) => {
                        if (index === 0) {
                            item.parentElement.querySelector('span').textContent = message;
                        }
                    });
                }
            }
            
            // Generate creative token name based on concept
            generateCreativeTokenName(userConcept) {
                const conceptLower = userConcept.toLowerCase();
                
                // Smart name generation based on concept keywords
                let tokenName = 'MemeCoin';
                let tokenSymbol = 'MEME';
                
                // Animal-based names
                if (conceptLower.includes('cat')) {
                    const catNames = ['KittyCoin', 'WhiskerToken', 'PurrCoin', 'CatCEO', 'MeowMeme'];
                    const catSymbols = ['KITTY', 'WHISK', 'PURR', 'CCEO', 'MEOW'];
                    const index = Math.floor(Math.random() * catNames.length);
                    tokenName = catNames[index];
                    tokenSymbol = catSymbols[index];
                } else if (conceptLower.includes('dog')) {
                    const dogNames = ['PuppyCoin', 'WoofToken', 'BarkCoin', 'DogeCEO', 'WagMeme'];
                    const dogSymbols = ['PUPPY', 'WOOF', 'BARK', 'DCEO', 'WAG'];
                    const index = Math.floor(Math.random() * dogNames.length);
                    tokenName = dogNames[index];
                    tokenSymbol = dogSymbols[index];
                } else if (conceptLower.includes('duck')) {
                    const duckNames = ['QuackCoin', 'DuckMeme', 'FeatherToken', 'PondCoin', 'WaddleToken'];
                    const duckSymbols = ['QUACK', 'DUCK', 'FEATH', 'POND', 'WADDLE'];
                    const index = Math.floor(Math.random() * duckNames.length);
                    tokenName = duckNames[index];
                    tokenSymbol = duckSymbols[index];
                } else if (conceptLower.includes('penguin')) {
                    const penguinNames = ['ChillCoin', 'IceMeme', 'PenguinPay', 'ArcticToken', 'SlideToken'];
                    const penguinSymbols = ['CHILL', 'ICE', 'PENG', 'ARTIC', 'SLIDE'];
                    const index = Math.floor(Math.random() * penguinNames.length);
                    tokenName = penguinNames[index];
                    tokenSymbol = penguinSymbols[index];
                }
                
                // Theme-based names
                else if (conceptLower.includes('space') || conceptLower.includes('rocket') || conceptLower.includes('moon')) {
                    const spaceNames = ['MoonMeme', 'RocketCoin', 'SpaceToken', 'CosmicCoin', 'StarMeme'];
                    const spaceSymbols = ['MOON', 'ROCKET', 'SPACE', 'COSMIC', 'STAR'];
                    const index = Math.floor(Math.random() * spaceNames.length);
                    tokenName = spaceNames[index];
                    tokenSymbol = spaceSymbols[index];
                } else if (conceptLower.includes('food') || conceptLower.includes('taco') || conceptLower.includes('pizza')) {
                    const foodNames = ['TastyCoin', 'YummyToken', 'FlavorMeme', 'ChefCoin', 'FoodToken'];
                    const foodSymbols = ['TASTY', 'YUMMY', 'FLAVOR', 'CHEF', 'FOOD'];
                    const index = Math.floor(Math.random() * foodNames.length);
                    tokenName = foodNames[index];
                    tokenSymbol = foodSymbols[index];
                } else if (conceptLower.includes('robot') || conceptLower.includes('cyber') || conceptLower.includes('tech')) {
                    const techNames = ['CyberCoin', 'RoboToken', 'TechMeme', 'DigitalCoin', 'ByteToken'];
                    const techSymbols = ['CYBER', 'ROBO', 'TECH', 'DIGI', 'BYTE'];
                    const index = Math.floor(Math.random() * techNames.length);
                    tokenName = techNames[index];
                    tokenSymbol = techSymbols[index];
                }
                
                // Fallback to creative random names
                else {
                    const randomNames = ['ViralCoin', 'MemeKing', 'FunToken', 'LolCoin', 'HypeToken', 'WinCoin', 'LegendToken'];
                    const randomSymbols = ['VIRAL', 'KING', 'FUN', 'LOL', 'HYPE', 'WIN', 'LEGEND'];
                    const index = Math.floor(Math.random() * randomNames.length);
                    tokenName = randomNames[index];
                    tokenSymbol = randomSymbols[index];
                }
                
                return { tokenName, tokenSymbol };
            }
            
            // Display enhanced token preview with all metadata
            displayEnhancedTokenPreview() {
                // Update token details
                document.getElementById('aiTokenName').textContent = AppState.currentTokenData.tokenName || 'Generated Token';
                document.getElementById('aiTokenSymbol').textContent = AppState.currentTokenData.tokenSymbol || 'TOKEN';
                document.getElementById('aiTokenDescription').textContent = AppState.currentTokenData.description || 'AI generated meme token description';
                
                // Handle enhanced image display
                const imageContainer = document.getElementById('aiTokenImage');
                if (AppState.currentTokenData.imageUrl) {
                    const imageUrl = AppState.currentTokenData.imageUrl;
                    const provider = AppState.currentTokenData.imageProvider || 'AI';
                    const score = AppState.currentTokenData.similarityScore;
                    
                    imageContainer.innerHTML = 
                        `<img src="${imageUrl}" alt="${AppState.currentTokenData.tokenName}" 
                              class="w-full h-full object-cover rounded-xl"
                              onerror="this.parentElement.innerHTML='<div class=\\'text-center text-red-500 p-4\\'>Image failed to load</div>'">
                         <div class="absolute bottom-2 right-2 bg-purple-600 text-white text-xs px-2 py-1 rounded-full shadow-lg">
                             ü§ñ ${provider}
                         </div>
                         <div class="absolute top-2 left-2 bg-green-600 text-white text-xs px-2 py-1 rounded-full shadow-lg">
                             ‚úÖ ${score ? (score * 100).toFixed(0) + '%' : 'Perfect'}
                         </div>`;
                    
                    // Show AI stats
                    const statsContainer = document.getElementById('aiImageStats');
                    if (statsContainer) {
                        statsContainer.classList.remove('hidden');
                        document.getElementById('aiProvider').textContent = provider;
                        document.getElementById('aiSimilarity').textContent = score ? (score * 100).toFixed(1) + '%' : '95%';
                        
                        const promptPreview = AppState.currentTokenData.exactPrompt || 'Enhanced AI prompt';
                        document.getElementById('aiPromptPreview').textContent = promptPreview.substring(0, 80) + '...';
                    }
                    
                } else {
                    // Fallback display
                    imageContainer.innerHTML = 
                        `<div class="text-center text-gray-500 p-4">
                            <i class="fas fa-magic text-4xl mb-2 text-purple-400"></i>
                            <p class="text-sm">Demo mode - Image ready for generation</p>
                         </div>`;
                }
            }
                    
                } catch (error) {
                    console.error('‚ùå Enhanced AI generation error:', error);
                    const loader = document.getElementById('aiGenerationLoader');
                    loader.classList.add('hidden');
                    
                    // Show specific error feedback
                    if (error.message.includes('API key')) {
                        showNotification('‚ö†Ô∏è AI generation using demo mode - perfect for testing!', 'warning');
                    } else {
                        showNotification(`‚ùå AI generation error: ${error.message}`, 'error');
                    }
                }
            }
            
            async createAIToken() {
                if (!AppState.currentTokenData) {
                    showNotification('Please generate a token first', 'warning');
                    return;
                }
                
                // Get current values from AI form
                const supply = parseInt(document.getElementById('aiTokenSupply').value) || 1000000000;
                const decimals = parseInt(document.getElementById('aiTokenDecimals').value) || 9;
                const revokeMintAuthority = document.getElementById('aiRevokeMintAuthority').checked;
                const revokeFreezeAuthority = document.getElementById('aiRevokeFreezeAuthority').checked;
                const revokeUpdateAuthority = document.getElementById('aiRevokeUpdateAuthority').checked;
                
                // Update token data with current form values
                const tokenData = {
                    ...AppState.currentTokenData,
                    supply: supply,
                    decimals: decimals,
                    revokeMintAuthority: revokeMintAuthority,
                    revokeFreezeAuthority: revokeFreezeAuthority,
                    revokeUpdateAuthority: revokeUpdateAuthority,
                    transactionFeePercentage: 0.0, // Default for AI mode
                    feeCollectorWallet: null,
                    socialLinks: {}
                };
                
                await this.tokenCreator.createToken(tokenData);
            }
            
            handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Validate file
                if (!file.type.startsWith('image/')) {
                    showNotification('Please select a valid image file', 'error');
                    return;
                }
                
                if (file.size > 5 * 1024 * 1024) { // 5MB limit
                    showNotification('Image size must be less than 5MB', 'error');
                    return;
                }
                
                // Display preview
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('previewImg').src = e.target.result;
                    document.getElementById('imagePreview').classList.remove('hidden');
                    document.getElementById('imageUploadArea').classList.add('hidden');
                };
                reader.readAsDataURL(file);
            }
            
            generateAIPrompt(tokenName, tokenDescription) {
                if (!tokenName) return '';
                
                // Use the enhanced unique image prompt generator
                return uniqueTokenGenerator.generateUniqueImagePrompt(tokenName, tokenDescription || '');
            }
            
            async generateAIImage() {
                try {
                    this.tokenCreator.walletManager.showLoading('generateImage');
                    showNotification('üé® Generating AI image with real AI...', 'info');
                    
                    // Get token name and description for the prompt
                    const tokenName = document.getElementById('manualTokenName').value || 'cryptocurrency token';
                    const tokenDescription = document.getElementById('manualTokenDescription').value || '';
                    
                    // Generate dynamic prompt based on token name and description
                    const prompt = this.generateAIPrompt(tokenName, tokenDescription);
                    
                    try {
                        // Generate unique seed for this specific image generation
                        const uniqueSeed = uniqueTokenGenerator.generateUniqueSeed(tokenName, tokenDescription);
                        
                        // Call backend AI image generation with unique seed
                        const response = await makeAPICall('/images/generate', {
                            method: 'POST',
                            body: JSON.stringify({
                                prompt: prompt,
                                style: 'cartoon',  // Meme-style cute mascot
                                size: '512x512',
                                count: 1,
                                seed: uniqueSeed,  // Unique seed to prevent duplication
                                randomize: true,   // Enable randomization
                                noFallback: true   // Strictly no stock photos
                            })
                        });
                        
                        const generatedImage = response.data.images[0];
                        const imageUrl = generatedImage.storageUrl || generatedImage.url;
                        
                        document.getElementById('previewImg').src = imageUrl;
                        document.getElementById('imagePreview').classList.remove('hidden');
                        document.getElementById('imageUploadArea').classList.add('hidden');
                        
                        showNotification('‚úÖ AI image generated successfully!', 'success');
                        
                    } catch (apiError) {
                        console.warn('Backend AI generation failed - NO FALLBACK TO STOCK IMAGES:', apiError);
                        
                        // STRICTLY ENFORCE: NO STOCK IMAGES OR DEFAULT PHOTOS
                        // Generate unique seed for this failed attempt
                        const uniqueSeed = uniqueTokenGenerator.generateUniqueSeed(tokenName, tokenDescription);
                        
                        // Create AI generation requirement placeholder with unique seed
                        const aiPlaceholder = `data:text/html,<div style="width:512px;height:512px;background:linear-gradient(45deg, #667eea 0%, #764ba2 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;color:white;font-family:Arial;text-align:center;padding:20px;box-sizing:border-box;"><h3>üé® AI Generation Required</h3><p style="margin:10px 0;font-weight:bold;">Token: ${tokenName}</p><p style="font-size:11px;opacity:0.9;margin:5px 0;">Unique Seed: ${uniqueSeed.substring(0, 12)}...</p><p style="font-size:12px;opacity:0.8;margin:10px 0;">Prompt: ${prompt.substring(0, 80)}...</p><p style="font-size:10px;margin-top:15px;color:#ffeb3b;"><strong>‚ö†Ô∏è NO STOCK PHOTOS ALLOWED</strong></p><p style="font-size:9px;margin-top:5px;">AI service required for unique illustration</p></div>`;
                        
                        document.getElementById('previewImg').src = aiPlaceholder;
                        document.getElementById('imagePreview').classList.remove('hidden');
                        document.getElementById('imageUploadArea').classList.add('hidden');
                        
                        showNotification('üö´ AI service required - No stock photos allowed. Each token needs unique AI illustration.', 'error');
                    }
                    
                } catch (error) {
                    console.error('‚ùå AI image generation failed:', error);
                    showNotification('AI image generation failed: ' + error.message, 'error');
                } finally {
                    this.tokenCreator.walletManager.hideLoading('generateImage');
                }
            }
            
            removeImage() {
                document.getElementById('imagePreview').classList.add('hidden');
                document.getElementById('imageUploadArea').classList.remove('hidden');
                document.getElementById('imageUpload').value = '';
            }

            validateTransactionFee() {
                const feeInput = document.getElementById('transactionFeePercentage');
                const feeError = document.getElementById('feeError');
                const feeConfirmation = document.getElementById('feeConfirmation');
                const feeDisplayValue = document.getElementById('feeDisplayValue');
                const feeDescription = document.getElementById('feeDescription');
                
                if (!feeInput) return true;
                
                const feeValue = parseFloat(feeInput.value);
                
                // Check if value is valid number and within range
                if (isNaN(feeValue) || feeValue < 0.0 || feeValue > 5.0) {
                    feeError.classList.remove('hidden');
                    feeConfirmation.classList.add('hidden');
                    feeInput.classList.add('border-red-500');
                    feeInput.classList.remove('border-gray-300');
                    return false;
                }
                
                // Check if value is in 0.1% increments
                const rounded = Math.round(feeValue * 10) / 10;
                if (Math.abs(feeValue - rounded) > 0.01) {
                    feeError.classList.remove('hidden');
                    feeConfirmation.classList.add('hidden');
                    feeInput.classList.add('border-red-500');
                    feeInput.classList.remove('border-gray-300');
                    return false;
                }
                
                // Valid fee - show confirmation
                feeError.classList.add('hidden');
                feeConfirmation.classList.remove('hidden');
                feeInput.classList.remove('border-red-500');
                feeInput.classList.add('border-gray-300');
                
                // Update confirmation text
                if (feeDisplayValue) {
                    feeDisplayValue.textContent = feeValue.toFixed(1);
                }
                
                if (feeDescription) {
                    if (feeValue === 0.0) {
                        feeDescription.textContent = 'No fees will be charged on transfers.';
                    } else {
                        feeDescription.textContent = `This fee will be applied to every transfer using Token22 Transfer Hook and sent to the specified wallet.`;
                    }
                }
                
                // Show/hide fee collector section based on fee value
                this.toggleFeeCollectorSection(feeValue > 0);
                
                return true;
            }

            toggleFeeCollectorSection(show) {
                const feeCollectorSection = document.getElementById('feeCollectorSection');
                if (feeCollectorSection) {
                    if (show) {
                        feeCollectorSection.classList.remove('hidden');
                    } else {
                        feeCollectorSection.classList.add('hidden');
                        // Clear the input when hidden
                        const feeCollectorInput = document.getElementById('feeCollectorWallet');
                        if (feeCollectorInput) {
                            feeCollectorInput.value = '';
                        }
                    }
                }
            }

            validateSocialLinks() {
                const socialLinksError = document.getElementById('socialLinksError');
                const inputs = [
                    { id: 'twitterLink', name: 'Twitter' },
                    { id: 'telegramLink', name: 'Telegram' },
                    { id: 'discordLink', name: 'Discord' },
                    { id: 'instagramLink', name: 'Instagram' },
                    { id: 'youtubeLink', name: 'YouTube' },
                    { id: 'tiktokLink', name: 'TikTok' }
                ];
                
                let hasErrors = false;
                
                inputs.forEach(({ id, name }) => {
                    const input = document.getElementById(id);
                    if (input && input.value.trim()) {
                        const url = input.value.trim();
                        
                        // Basic URL validation
                        if (!this.isValidURL(url)) {
                            hasErrors = true;
                            input.classList.add('border-red-500');
                            input.classList.remove('border-gray-300');
                        } else {
                            input.classList.remove('border-red-500');
                            input.classList.add('border-gray-300');
                        }
                    } else {
                        // Empty is valid (optional fields)
                        input.classList.remove('border-red-500');
                        input.classList.add('border-gray-300');
                    }
                });
                
                if (hasErrors) {
                    socialLinksError.classList.remove('hidden');
                } else {
                    socialLinksError.classList.add('hidden');
                }
                
                return !hasErrors;
            }

            isValidURL(string) {
                try {
                    const url = new URL(string);
                    return url.protocol === 'https:';
                } catch (_) {
                    return false;
                }
            }

            toggleSocialLinksFields() {
                const noSocialLinksCheckbox = document.getElementById('noSocialLinks');
                const socialInputs = ['twitterLink', 'telegramLink', 'discordLink', 'instagramLink', 'youtubeLink', 'tiktokLink'];
                
                if (!noSocialLinksCheckbox) return;
                
                const isDisabled = noSocialLinksCheckbox.checked;
                
                socialInputs.forEach(inputId => {
                    const input = document.getElementById(inputId);
                    if (input) {
                        input.disabled = isDisabled;
                        if (isDisabled) {
                            input.classList.add('bg-gray-100', 'cursor-not-allowed');
                            input.value = '';
                        } else {
                            input.classList.remove('bg-gray-100', 'cursor-not-allowed');
                        }
                    }
                });
                
                // Hide validation errors when disabled
                if (isDisabled) {
                    const socialLinksError = document.getElementById('socialLinksError');
                    if (socialLinksError) {
                        socialLinksError.classList.add('hidden');
                    }
                }
            }

            useMyWalletForFees() {
                const feeCollectorInput = document.getElementById('feeCollectorWallet');
                if (feeCollectorInput && AppState.wallet) {
                    feeCollectorInput.value = AppState.wallet;
                    this.validateFeeCollectorWallet();
                } else if (!AppState.wallet) {
                    showNotification('Please connect your wallet first', 'warning');
                }
            }

            validateFeeCollectorWallet() {
                const feeCollectorInput = document.getElementById('feeCollectorWallet');
                const feeCollectorError = document.getElementById('feeCollectorError');
                
                if (!feeCollectorInput) return true;
                
                const walletAddress = feeCollectorInput.value.trim();
                
                // If empty, that's ok - we'll use the creator's wallet
                if (!walletAddress) {
                    feeCollectorError.classList.add('hidden');
                    feeCollectorInput.classList.remove('border-red-500');
                    feeCollectorInput.classList.add('border-gray-300');
                    return true;
                }
                
                // Validate Solana address format
                try {
                    // Basic length and character validation
                    if (walletAddress.length < 32 || walletAddress.length > 44) {
                        throw new Error('Invalid length');
                    }
                    
                    // Check if it's a valid base58 string (approximate check)
                    if (!/^[1-9A-HJ-NP-Za-km-z]+$/.test(walletAddress)) {
                        throw new Error('Invalid characters');
                    }
                    
                    feeCollectorError.classList.add('hidden');
                    feeCollectorInput.classList.remove('border-red-500');
                    feeCollectorInput.classList.add('border-gray-300');
                    return true;
                    
                } catch (error) {
                    feeCollectorError.classList.remove('hidden');
                    feeCollectorInput.classList.add('border-red-500');
                    feeCollectorInput.classList.remove('border-gray-300');
                    return false;
                }
            }

            async showFeeConfirmationDialog(feePercentage) {
                return new Promise((resolve) => {
                    // Create confirmation dialog
                    const dialogHTML = `
                        <div id="feeConfirmDialog" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div class="bg-white rounded-xl p-6 max-w-md mx-4 shadow-2xl">
                                <div class="text-center mb-6">
                                    <div class="w-16 h-16 mx-auto bg-yellow-100 rounded-full flex items-center justify-center mb-4">
                                        <i class="fas fa-percentage text-yellow-600 text-2xl"></i>
                                    </div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">Confirm Transaction Fee</h3>
                                    <p class="text-gray-600">Please confirm your transaction fee settings before creating the token.</p>
                                </div>
                                
                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                                    <div class="flex items-start">
                                        <i class="fas fa-info-circle text-blue-500 mt-0.5 mr-3"></i>
                                        <div class="text-sm text-blue-700">
                                            <strong>Transaction Fee: ${feePercentage}%</strong><br>
                                            ${parseFloat(feePercentage) === 0 ? 
                                                'No fees will be charged on transfers. Standard SPL token functionality will be used.' : 
                                                'This fee will be applied to every transfer using Token22 Transfer Hook and automatically sent to your specified wallet. This setting cannot be changed after token creation.'
                                            }
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="flex space-x-3">
                                    <button id="cancelFeeConfirm" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors">
                                        Cancel
                                    </button>
                                    <button id="confirmFeeConfirm" class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                                        Confirm & Create Token
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.body.insertAdjacentHTML('beforeend', dialogHTML);
                    
                    const dialog = document.getElementById('feeConfirmDialog');
                    const cancelBtn = document.getElementById('cancelFeeConfirm');
                    const confirmBtn = document.getElementById('confirmFeeConfirm');
                    
                    cancelBtn.addEventListener('click', () => {
                        dialog.remove();
                        resolve(false);
                    });
                    
                    confirmBtn.addEventListener('click', () => {
                        dialog.remove();
                        resolve(true);
                    });
                    
                    // Close on backdrop click
                    dialog.addEventListener('click', (e) => {
                        if (e.target === dialog) {
                            dialog.remove();
                            resolve(false);
                        }
                    });
                });
            }
            
            async createManualToken() {
                const name = document.getElementById('manualTokenName').value.trim();
                const symbol = document.getElementById('manualTokenSymbol').value.trim().toUpperCase();
                const description = document.getElementById('manualTokenDescription').value.trim();
                const imageElement = document.getElementById('previewImg');
                const feeInput = document.getElementById('transactionFeePercentage');
                
                // Basic validation
                if (!name || !symbol || !description) {
                    showNotification('Please fill in all required fields', 'warning');
                    return;
                }
                
                // Uniqueness validation
                const tempTokenData = { name, symbol, description };
                if (GeneratedTokens.isDuplicate(tempTokenData)) {
                    showNotification('‚ùå This token name, symbol, or description has already been used. Please create something unique!', 'error');
                    return;
                }
                
                // Length validation
                if (name.length > 32) {
                    showNotification('Token name must be 32 characters or less', 'warning');
                    return;
                }
                
                if (symbol.length > 10) {
                    showNotification('Token symbol must be 10 characters or less', 'warning');
                    return;
                }
                
                if (description.length < 50) {
                    showNotification('Token description must be at least 50 characters to ensure uniqueness', 'warning');
                    return;
                }
                
                // Validate transaction fee
                if (!this.validateTransactionFee()) {
                    showNotification('Please enter a valid transaction fee between 0.0% and 5.0% in 0.1% increments', 'error');
                    feeInput.focus();
                    return;
                }
                
                const feePercentage = parseFloat(feeInput.value);
                
                // Validate fee collector wallet if fee > 0
                if (feePercentage > 0 && !this.validateFeeCollectorWallet()) {
                    showNotification('Please enter a valid fee collector wallet address', 'error');
                    document.getElementById('feeCollectorWallet').focus();
                    return;
                }
                
                // Validate social media links
                if (!this.validateSocialLinks()) {
                    showNotification('Please enter valid social media URLs (starting with https://)', 'error');
                    return;
                }
                
                // Get social media links
                const noSocialLinks = document.getElementById('noSocialLinks').checked;
                const socialLinks = {
                    twitter: noSocialLinks ? '' : (document.getElementById('twitterLink').value.trim() || ''),
                    telegram: noSocialLinks ? '' : (document.getElementById('telegramLink').value.trim() || ''),
                    discord: noSocialLinks ? '' : (document.getElementById('discordLink').value.trim() || ''),
                    instagram: noSocialLinks ? '' : (document.getElementById('instagramLink').value.trim() || ''),
                    youtube: noSocialLinks ? '' : (document.getElementById('youtubeLink').value.trim() || ''),
                    tiktok: noSocialLinks ? '' : (document.getElementById('tiktokLink').value.trim() || ''),
                    noSocialLinks: noSocialLinks
                };
                
                // Get fee collector wallet
                const feeCollectorWallet = document.getElementById('feeCollectorWallet').value.trim() || null;
                
                // Get supply and decimal values
                const supply = parseInt(document.getElementById('tokenSupply').value) || 1000000000;
                const decimals = parseInt(document.getElementById('tokenDecimals').value) || 9;
                
                // Get authority settings
                const revokeMintAuthority = document.getElementById('revokeMintAuthority').checked;
                const revokeFreezeAuthority = document.getElementById('revokeFreezeAuthority').checked;
                const revokeUpdateAuthority = document.getElementById('revokeUpdateAuthority').checked;
                
                // Show fee confirmation dialog
                const confirmed = await this.showFeeConfirmationDialog(feePercentage.toFixed(1));
                if (!confirmed) {
                    return;
                }
                
                // Check if we have an image, if not, generate unique AI prompt
                let useAI = false;
                let imagePrompt = '';
                
                if (!imageElement || !imageElement.src || imageElement.src.includes('placeholder')) {
                    useAI = true;
                    imagePrompt = uniqueTokenGenerator.generateUniqueImagePrompt(name, description);
                    showNotification('üé® Automatically generating unique AI image for your token...', 'info');
                }
                
                const tokenData = {
                    name,
                    symbol,
                    description,
                    image: (imageElement && imageElement.src) ? imageElement.src : null,
                    useAI: useAI,
                    imagePrompt: imagePrompt,
                    transactionFeePercentage: feePercentage,
                    feeCollectorWallet: feeCollectorWallet,
                    socialLinks: socialLinks,
                    // New fields
                    supply: supply,
                    decimals: decimals,
                    revokeMintAuthority: revokeMintAuthority,
                    revokeFreezeAuthority: revokeFreezeAuthority,
                    revokeUpdateAuthority: revokeUpdateAuthority
                };
                
                // Add to generated tokens to prevent future duplicates
                GeneratedTokens.add(tokenData);
                
                // Show preview before creation
                this.showTokenPreview(tokenData);
            }
            
            showTokenPreview(tokenData) {
                // Create preview modal
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
                modal.innerHTML = `
                    <div class="bg-white rounded-2xl p-8 max-w-2xl w-full max-h-90vh overflow-y-auto">
                        <h2 class="text-3xl font-bold text-gray-800 mb-6 text-center">üéØ Token Preview</h2>
                        
                        <div class="bg-gradient-to-r from-purple-100 to-blue-100 rounded-xl p-6 mb-6">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">üìù Token Details</h3>
                                    <div class="space-y-2 text-sm">
                                        <p><span class="font-semibold">Name:</span> ${tokenData.name}</p>
                                        <p><span class="font-semibold">Symbol:</span> ${tokenData.symbol}</p>
                                        <p><span class="font-semibold">Fee:</span> ${tokenData.transactionFeePercentage}%</p>
                                    </div>
                                </div>
                                
                                <div class="text-center">
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">üé® Image</h3>
                                    <div class="w-32 h-32 mx-auto bg-gray-100 rounded-xl flex items-center justify-center">
                                        ${tokenData.image ? 
                                            `<img src="${tokenData.image}" alt="${tokenData.name}" class="w-full h-full object-cover rounded-xl">` :
                                            `<span class="text-gray-500 text-sm">AI Generated</span>`
                                        }
                                    </div>
                                </div>
                            </div>
                            
                            <div class="mt-4">
                                <h3 class="text-lg font-bold text-gray-800 mb-2">üìñ Description</h3>
                                <p class="text-gray-600 text-sm leading-relaxed">${tokenData.description}</p>
                            </div>
                            
                            <div class="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                                <div class="flex items-center gap-2 mb-2">
                                    <span class="text-green-600">‚úÖ</span>
                                    <span class="font-semibold text-green-800">Uniqueness Validation Passed</span>
                                </div>
                                <p class="text-green-700 text-sm">All token details are unique and have been validated against existing tokens.</p>
                            </div>
                        </div>
                        
                        <div class="flex gap-4 justify-center">
                            <button onclick="this.closest('.fixed').remove()" 
                                    class="px-6 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                                Cancel
                            </button>
                            <button onclick="confirmTokenCreation(${JSON.stringify(tokenData).replace(/"/g, '&quot;')}); this.closest('.fixed').remove();" 
                                    class="px-6 py-3 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg hover:from-purple-700 hover:to-blue-700 transition-colors">
                                ‚úÖ Create Token
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add global function for confirmation
                window.confirmTokenCreation = async (data) => {
                    await this.tokenCreator.createToken(data);
                };
            }
            
            // Real-time validation methods
            validateTokenName() {
                const nameInput = document.getElementById('manualTokenName');
                const validation = document.getElementById('nameValidation');
                const name = nameInput.value.trim();
                
                if (!name) {
                    validation.innerHTML = '';
                    nameInput.classList.remove('border-red-500', 'border-green-500');
                    nameInput.classList.add('border-gray-300');
                    return;
                }
                
                if (name.length > 32) {
                    validation.innerHTML = '<span class="text-red-500">‚ö†Ô∏è Maximum 32 characters</span>';
                    nameInput.classList.add('border-red-500');
                    nameInput.classList.remove('border-green-500', 'border-gray-300');
                    return;
                }
                
                if (GeneratedTokens.names.has(name.toLowerCase())) {
                    validation.innerHTML = '<span class="text-red-500">‚ùå This name has already been used</span>';
                    nameInput.classList.add('border-red-500');
                    nameInput.classList.remove('border-green-500', 'border-gray-300');
                } else {
                    validation.innerHTML = '<span class="text-green-500">‚úÖ Name is unique</span>';
                    nameInput.classList.add('border-green-500');
                    nameInput.classList.remove('border-red-500', 'border-gray-300');
                }
            }
            
            validateTokenSymbol() {
                const symbolInput = document.getElementById('manualTokenSymbol');
                const validation = document.getElementById('symbolValidation');
                const symbol = symbolInput.value.trim().toUpperCase();
                
                if (!symbol) {
                    validation.innerHTML = '';
                    symbolInput.classList.remove('border-red-500', 'border-green-500');
                    symbolInput.classList.add('border-gray-300');
                    return;
                }
                
                if (symbol.length > 10) {
                    validation.innerHTML = '<span class="text-red-500">‚ö†Ô∏è Maximum 10 characters</span>';
                    symbolInput.classList.add('border-red-500');
                    symbolInput.classList.remove('border-green-500', 'border-gray-300');
                    return;
                }
                
                if (symbol.length < 3) {
                    validation.innerHTML = '<span class="text-yellow-500">‚ö†Ô∏è Minimum 3 characters recommended</span>';
                    symbolInput.classList.remove('border-red-500', 'border-green-500');
                    symbolInput.classList.add('border-gray-300');
                    return;
                }
                
                if (GeneratedTokens.symbols.has(symbol)) {
                    validation.innerHTML = '<span class="text-red-500">‚ùå This symbol has already been used</span>';
                    symbolInput.classList.add('border-red-500');
                    symbolInput.classList.remove('border-green-500', 'border-gray-300');
                } else {
                    validation.innerHTML = '<span class="text-green-500">‚úÖ Symbol is unique</span>';
                    symbolInput.classList.add('border-green-500');
                    symbolInput.classList.remove('border-red-500', 'border-gray-300');
                }
            }
            
            validateTokenDescription() {
                const descInput = document.getElementById('manualTokenDescription');
                const validation = document.getElementById('descriptionValidation');
                const counter = document.getElementById('descriptionCounter');
                const description = descInput.value.trim();
                
                // Update character counter
                counter.textContent = `${description.length} / 50 characters minimum`;
                
                if (!description) {
                    validation.innerHTML = '';
                    counter.className = 'mt-1 text-xs text-gray-500';
                    descInput.classList.remove('border-red-500', 'border-green-500');
                    descInput.classList.add('border-gray-300');
                    return;
                }
                
                if (description.length < 50) {
                    validation.innerHTML = '<span class="text-yellow-500">‚ö†Ô∏è Add more details for uniqueness</span>';
                    counter.className = 'mt-1 text-xs text-yellow-500';
                    descInput.classList.remove('border-red-500', 'border-green-500');
                    descInput.classList.add('border-gray-300');
                    return;
                }
                
                if (GeneratedTokens.descriptions.has(description.toLowerCase())) {
                    validation.innerHTML = '<span class="text-red-500">‚ùå This description has already been used</span>';
                    counter.className = 'mt-1 text-xs text-red-500';
                    descInput.classList.add('border-red-500');
                    descInput.classList.remove('border-green-500', 'border-gray-300');
                } else {
                    validation.innerHTML = '<span class="text-green-500">‚úÖ Description is unique</span>';
                    counter.className = 'mt-1 text-xs text-green-500';
                    descInput.classList.add('border-green-500');
                    descInput.classList.remove('border-red-500', 'border-gray-300');
                }
            }
        }

        // ================================
        // APP INITIALIZATION
        // ================================
        
        async function initializeApp() {
            try {
                console.log('üéØ Initializing SolMeme Creator...');
                
                // Initialize managers
                const rpcManager = new RPCManager();
                const walletManager = new WalletManager(rpcManager);
                const tokenCreator = new TokenCreator(walletManager);
                const uiManager = new UIManager(tokenCreator);
                
                // Store globally for access
                window.app = {
                    rpcManager,
                    walletManager,
                    tokenCreator,
                    uiManager
                };
                
                // Initialize RPC connection
                try {
                    console.log('üîÑ Initializing RPC connection...');
                    rpcManager.updateNetworkStatus('connecting', null, null);
                    
                    await rpcManager.initializeConnection();
                    console.log('‚úÖ RPC connection initialized');
                    
                    // Force status update after successful connection
                    if (AppState.connection) {
                        const currentEndpoint = rpcManager.getCurrentEndpoint();
                        rpcManager.updateNetworkStatus('connected', currentEndpoint.name, await AppState.connection.getVersion());
                        await rpcManager.updateBlockHeight();
                    }
                } catch (error) {
                    console.error('‚ùå RPC initialization failed:', error);
                    rpcManager.updateNetworkStatus('error', null, null);
                    showNotification('Network connection failed. Some features may not work.', 'warning');
                }
                
                // Check for existing wallet connection
                await walletManager.checkExistingConnection();
                
                // Set up wallet event listeners
                document.getElementById('connectWallet').addEventListener('click', () => {
                    walletManager.connect();
                });
                
                document.getElementById('disconnectWallet').addEventListener('click', () => {
                    walletManager.disconnect();
                });
                
                // Set up periodic updates
                setInterval(() => {
                    if (AppState.networkHealthy) {
                        rpcManager.updateBlockHeight();
                    }
                    
                    if (AppState.wallet) {
                        walletManager.fetchBalance();
                    }
                }, CONFIG.BALANCE_REFRESH_INTERVAL);
                
                console.log('‚úÖ SolMeme Creator initialized successfully');
                
                // Add test button for meme generation
                addTestButton();
                
                showNotification('SolMeme Creator ready!', 'success', 3000);
                
            } catch (error) {
                console.error('‚ùå App initialization failed:', error);
                showNotification('Failed to initialize app: ' + error.message, 'error');
            }
        }

        // ================================
        // START APPLICATION
        // ================================
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üåü Starting SolMeme Creator - Production Version');
            initializeApp();
        });
        
        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            showNotification('An unexpected error occurred. Please refresh the page.', 'error');
        });
        
        // ================================
        // PROMOTIONAL WEBSITE UTILITIES
        // ================================
        
        // Copy promotional website URL
        function copyPromoUrl() {
            const promoUrl = document.getElementById('promoWebsiteUrl').textContent;
            navigator.clipboard.writeText(promoUrl).then(() => {
                showToast('‚úÖ Promotional website URL copied!');
            }).catch(() => {
                showToast('‚ùå Failed to copy URL');
            });
        }
        
        // Share on Twitter/X
        function shareOnTwitter() {
            const resultName = document.getElementById('resultName').textContent;
            const resultSymbol = document.getElementById('resultSymbol').textContent;
            const promoUrl = document.getElementById('promoWebsiteUrl').textContent;
            
            const text = `üöÄ Check out ${resultName} ($${resultSymbol}) - a new token on Solana! ${promoUrl} #Solana #Crypto #Meme`;
            const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
            
            window.open(twitterUrl, '_blank');
        }
        
        // Copy Discord message
        function copyDiscordMessage() {
            const resultName = document.getElementById('resultName').textContent;
            const resultSymbol = document.getElementById('resultSymbol').textContent;
            const contractAddress = document.getElementById('resultMintAddress').textContent;
            const promoUrl = document.getElementById('promoWebsiteUrl').textContent;
            
            const message = `üöÄ **${resultName} ($${resultSymbol})**

New token just launched on Solana!

üìú **Contract Address:**
\`${contractAddress}\`

üåê **Official Website:** ${promoUrl}

#Solana #Crypto #NewToken`;
            
            navigator.clipboard.writeText(message).then(() => {
                showToast('‚úÖ Discord message copied!');
            }).catch(() => {
                showToast('‚ùå Failed to copy message');
            });
        }
        
        // Share on Telegram
        function shareOnTelegram() {
            const resultName = document.getElementById('resultName').textContent;
            const resultSymbol = document.getElementById('resultSymbol').textContent;
            const promoUrl = document.getElementById('promoWebsiteUrl').textContent;
            
            const text = `üöÄ ${resultName} ($${resultSymbol}) - New Solana token! ${promoUrl}`;
            const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(promoUrl)}&text=${encodeURIComponent(text)}`;
            
            window.open(telegramUrl, '_blank');
        }
        
        // Auto-generate manual form fields
        async function autoGenerateManualFields() {
            try {
                console.log('üéØ Auto-generating unique token details for manual form...');
                
                // Show loading state
                const generateBtn = document.getElementById('autoGenerateFields');
                const originalText = generateBtn.innerHTML;
                generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Generating...';
                generateBtn.disabled = true;
                
                // Generate unique token data
                const tokenData = await uniqueTokenGenerator.generateUniqueToken();
                
                // Populate form fields
                document.getElementById('manualTokenName').value = tokenData.name;
                document.getElementById('manualTokenSymbol').value = tokenData.symbol;
                document.getElementById('manualTokenDescription').value = tokenData.description;
                
                // Trigger validation for all fields if app instance exists
                if (window.app && window.app.formManager) {
                    window.app.formManager.validateTokenName();
                    window.app.formManager.validateTokenSymbol();
                    window.app.formManager.validateTokenDescription();
                }
                
                // Show success notification
                showNotification('‚úÖ Unique token details generated successfully!', 'success');
                
                // Restore button
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
                
            } catch (error) {
                console.error('‚ùå Auto-generation failed:', error);
                showNotification('‚ùå Auto-generation failed. Please try again.', 'error');
                
                // Restore button
                const generateBtn = document.getElementById('autoGenerateFields');
                generateBtn.innerHTML = '<i class="fas fa-magic mr-2"></i>Auto-Generate Unique Token Details';
                generateBtn.disabled = false;
            }
        }

        // Toast notification for promo features
        function showToast(message) {
            // Create toast if it doesn't exist
            let toast = document.getElementById('promoToast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'promoToast';
                toast.className = 'fixed bottom-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 z-50';
                document.body.appendChild(toast);
            }
            
            toast.textContent = message;
            toast.classList.remove('translate-x-full');
            
            setTimeout(() => {
                toast.classList.add('translate-x-full');
            }, 3000);
        }
        
        // Handle wallet disconnect events
        if (window.solana) {
            window.solana.on('disconnect', () => {
                console.log('üëã Wallet disconnected by user');
                if (window.app && window.app.walletManager) {
                    window.app.walletManager.resetWalletState();
                }
            });
        }
        
        console.log('‚úÖ SolMeme Creator script loaded successfully');
        
        // Initialize Enhanced AI Image Generation System
        if (typeof EnhancedAIImageGenerator !== 'undefined') {
            window.enhancedAIGenerator = new EnhancedAIImageGenerator();
            console.log('üé® Enhanced AI Image Generation System initialized');
            console.log('üîß System includes: CLIP similarity, strict prompts, parallel generation');
        } else {
            console.warn('‚ö†Ô∏è Enhanced AI Image Generator not loaded');
        }
        
        // Initialize basic AI as fallback
        if (typeof AdvancedAIImageGenerator !== 'undefined') {
            window.aiImageGenerator = new AdvancedAIImageGenerator();
            console.log('üé® Basic AI Image Generation System initialized as fallback');
        }
        
        // Add character counter to AI concept input
        const aiThemeInput = document.getElementById('aiTheme');
        const charCounter = document.getElementById('conceptCharCount');
        
        if (aiThemeInput && charCounter) {
            aiThemeInput.addEventListener('input', function() {
                const count = this.value.length;
                charCounter.textContent = `${count} / 500`;
                
                if (count > 500) {
                    charCounter.className = 'text-xs text-red-500';
                    this.value = this.value.substring(0, 500);
                } else if (count > 400) {
                    charCounter.className = 'text-xs text-yellow-500';
                } else {
                    charCounter.className = 'text-xs text-gray-400';
                }
            });
        }
    </script>
</body>
</html>